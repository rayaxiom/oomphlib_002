//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//           Version 0.90. August 3, 2009.
//LIC// 
//LIC// Copyright (C) 2006-2009 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
//This header file contains classes and inline function definitions for
//matrices and their derived types

//Include guards to prevent multiple inclusion of the header
#ifndef OOMPH_MATRICES_HEADER
#define OOMPH_MATRICES_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif

#ifdef OOMPH_HAS_MPI
#include "mpi.h"
#endif

//oomph-lib headers
#include "Vector.h"
#include "oomph_utilities.h"
#include "linear_algebra_distribution.h"
#include "double_vector.h"

#ifdef OOMPH_HAS_TRILINOS
#include "trilinos_helpers.h"
#endif

namespace oomph
{

// Initialise dense pointer-based matrices/tensors?
#define OOMPH_INITIALISE_DENSE_MATRICES
#undef  OOMPH_INITIALISE_DENSE_MATRICES

//=================================================================
/// \short Abstract base class for matrices, templated by
/// the type of object that is stored in them and the type of matrix.
/// The MATRIX_TYPE template argument is used as part of the 
/// Curiously Recurring Template Pattern, see
/// http://en.wikipedia.org/wiki/Curiously_Recurring_Template_Pattern
/// The pattern is used to force the inlining of the round bracket access 
/// functions by ensuring that they are NOT virtual functions. 
//=================================================================
template<class T, class MATRIX_TYPE>
class Matrix
{

  protected:

 /// \short Range check to catch when an index is out of bounds, if so, it
 /// issues a warning message and dies by throwing an \c OomphLibError
 void range_check(const unsigned long& i, const unsigned long& j) const
  {
   if (i>=nrow())
    {
     std::ostringstream error_message;
     error_message << "Range Error: i=" << i << " is not in the range (0," 
                   << nrow()-1 << ")." << std::endl;
   
     throw OomphLibError(error_message.str(),
                         "Matrix::range_check()",
                         OOMPH_EXCEPTION_LOCATION);
    }
   else if (j>=ncol())
    {
     std::ostringstream error_message;
     error_message << "Range Error: j=" << j << " is not in the range (0," 
                   << ncol()-1 << ")." << std::endl;

      throw OomphLibError(error_message.str(),
                         "Matrix::range_check()",
                         OOMPH_EXCEPTION_LOCATION);
    }
  }


  public: 

 /// (Empty) constructor
 Matrix() {}

 /// Broken copy constructor
 Matrix(const Matrix& matrix) 
  {
   BrokenCopy::broken_copy("Matrix");
  } 
 
 /// Broken assignment operator
 void operator=(const Matrix&) 
  {
   BrokenCopy::broken_assign("Matrix");
  }

 /// Virtual (empty) destructor
 virtual ~Matrix(){}

 /// Return the number of rows of the matrix
 virtual unsigned long nrow() const=0;
 
 /// Return the number of columns of the matrix
 virtual unsigned long ncol() const=0;

 /// \short Round brackets to give access as a(i,j) for read only
 /// (we're not providing a general interface for component-wise write
 /// access since not all matrix formats allow efficient direct access!)
 /// The function uses the  MATRIX_TYPE template parameter to call the
 /// get_entry() function which must be defined in all derived classes
 /// that are to be fully instantiated.
 inline T operator()(const unsigned long &i, 
                            const unsigned long &j) const
  {
   return static_cast<MATRIX_TYPE const *>(this)->get_entry(i,j);
  }
 
 /// \short  Round brackets to give access as a(i,j) for read-write 
 /// access.
 /// The function uses the  MATRIX_TYPE template parameter to call the
 /// entry() function which must be defined in all derived classes
 /// that are to be fully instantiated. If the particular Matrix does
 /// not allow write access, the function should break with an error
 /// message.
 inline T& operator()(const unsigned long &i, 
                      const unsigned long &j)
  {
   return static_cast<MATRIX_TYPE*>(this)->entry(i,j);
  }
 
 /// \short Output function to print a matrix row-by-row, in the form \n
 /// a(0,0) a(0,1) ... \n
 /// a(1,0) a(1,1) ... \n
 /// ... \n
 /// to the stream outfile.
 /// Broken virtual since it might not be sensible to implement this for 
 /// some sparse matrices.
 virtual void output(std::ostream &outfile) const
  {
   throw OomphLibError(
    "Output function is not implemented for this matrix class",
    "Matrix::output()",
    OOMPH_EXCEPTION_LOCATION);
  }

 /// \short Indexed output function to print a matrix to the 
 /// stream outfile as i,j,a(i,j) for a(i,j)!=0 only
 virtual void sparse_indexed_output(std::ostream &outfile) const=0;

};


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////


//Forward definition of the linear solver class
 class LinearSolver; 

//=============================================================================
/// \short Abstract base class for matrices of doubles -- adds 
/// abstract interfaces for solving, LU decomposition and 
/// multiplication by vectors.
//=============================================================================
class DoubleMatrixBase
{
  protected:

 //Pointer to a linear solver
 LinearSolver* Linear_solver_pt;

 //Pointer to a default linear solver
 LinearSolver* Default_linear_solver_pt;

  public:

 /// (Empty) constructor. 
 DoubleMatrixBase() : Linear_solver_pt(0), Default_linear_solver_pt(0) {}

 /// Broken copy constructor
 DoubleMatrixBase(const DoubleMatrixBase& matrix) 
  {
   BrokenCopy::broken_copy("DoubleMatrixBase");
  } 
 
 /// Broken assignment operator
 void operator=(const DoubleMatrixBase&) 
  {
   BrokenCopy::broken_assign("DoubleMatrixBase");
  }

  /// Return the number of rows of the matrix
 virtual unsigned long nrow() const=0;
 
 /// Return the number of columns of the matrix
 virtual unsigned long ncol() const=0;

 /// virtual (empty) destructor
 virtual ~DoubleMatrixBase() { }

 /// \short Round brackets to give access as a(i,j) for read only
 /// (we're not providing a general interface for component-wise write
 /// access since not all matrix formats allow efficient direct access!)
 virtual double operator()(const unsigned long &i, 
                                  const unsigned long &j) const=0;

 
 /// Return a pointer to the linear solver object
 LinearSolver* &linear_solver_pt() {return Linear_solver_pt;}

 /// Return a pointer to the linear solver object (const version)
 LinearSolver* const &linear_solver_pt() const {return Linear_solver_pt;}

 /// \short Complete LU solve (replaces matrix by its LU decomposition
 /// and overwrites RHS with solution). The default should not need
 /// to be over-written
 void solve(DoubleVector &rhs);

 /// \short Complete LU solve (Nothing gets overwritten!). The default should
 /// not need to be overwritten
 void solve(const DoubleVector &rhs, DoubleVector &soln);

 /// \short Complete LU solve (replaces matrix by its LU decomposition
 /// and overwrites RHS with solution). The default should not need
 /// to be over-written
 void solve(Vector<double> &rhs);

 /// \short Complete LU solve (Nothing gets overwritten!). The default should
 /// not need to be overwritten
 void solve(const Vector<double> &rhs, Vector<double> &soln);

 /// \short Find the residual, i.e. r=b-Ax the residual
 virtual void residual(const DoubleVector &x, const DoubleVector &b, 
                       DoubleVector &residual_)
  {
   // compute residual = Ax
   this->multiply(x,residual_);

   // set residual to -residual (-Ax)
   unsigned nrow_local = residual_.nrow_local();
   double* residual_pt = residual_.values_pt();
   for (unsigned i = 0; i < nrow_local; i++)
    {
     residual_pt[i] = -residual_pt[i];
    }

   // set residual = b + residuals
   residual_ += b;
  }
 
 /// \short Find the maximum residual r=b-Ax -- generic version, can be 
 /// overloaded for specific derived classes where the
 /// max. can be determined "on the fly"
 virtual double max_residual(const DoubleVector &x, 
                             const DoubleVector &rhs)
  {
   DoubleVector res;
   residual(x,rhs,res);
   return res.max();
  }

 /// \short Multiply the matrix by the vector x: soln=Ax.
 virtual void multiply(const DoubleVector &x, DoubleVector &soln)const=0;

 /// \short Multiply the  transposed matrix by the vector x: soln=A^T x
 virtual void multiply_transpose(const DoubleVector &x,
                                 DoubleVector &soln)const=0;

 /// \short For every row, find the maximum absolute value of the
 /// entries in this row. Set all values that are less than alpha times
 /// this maximum to zero and return the resulting matrix in
 /// reduced_matrix. Note: Diagonal entries are retained regardless
 /// of their size. 
 //virtual void matrix_reduction(const double &alpha,
 //                              DoubleMatrixBase& reduced_matrix)=0;

};



///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////



//======================================================================
/// \short Class for dense matrices, storing all the values of the 
/// matrix as a pointer to a pointer with assorted output functions 
/// inherited from Matrix<T>. The curious recursive template pattern is
/// used here to pass the specific class to the base class so that
/// round bracket access can be inlined.
//======================================================================
template <class T>
class DenseMatrix : public Matrix<T, DenseMatrix<T> >
{

  protected:

 /// Internal representation of matrix as a pointer to data
 T* Matrixdata;

 /// Number of rows
 unsigned long N;
 
 /// Number of columns
 unsigned long M;
 
  public:

 /// Empty constructor, simply assign the lengths N and M to 0
 DenseMatrix() : Matrixdata(0), N(0), M(0) {}

 /// Copy constructor: Deep copy!
 DenseMatrix(const DenseMatrix& source_matrix) 
  {
   // Set row and column lengths
   N=source_matrix.nrow();
   M=source_matrix.ncol();
   // Assign space for the data
   Matrixdata = new T[N*M];
   // Copy the data across from the other matrix
   for(unsigned long i=0;i<N;i++)
    {
     for(unsigned long j=0;j<M;j++)
      {
       Matrixdata[M*i+j] = source_matrix(i,j);
      }
    }
  }

 /// Copy assignement 
 DenseMatrix& operator=(const DenseMatrix& source_matrix) 
  {
   // Don't create a new matrix if the assignement is the identity
   if (this != & source_matrix)
    {
     // Check row and column length
     unsigned long n=source_matrix.nrow();
     unsigned long m=source_matrix.ncol();
     if ( (N!=n) || (M!=m) )
      {
       resize(n,m);
      }
     // Copy entries across from the other matrix
     for (unsigned long i=0;i<N;i++)
      {
       for (unsigned long j=0;j<M;j++)
        {
         (*this)(i,j) = source_matrix(i,j);
        }
      }
    }
   // Return reference to object itself (i.e. de-reference this pointer)
   return *this;
  }
 
 /// \short The access function that will be called by the read-write
 /// round-bracket operator.
 inline T& entry(const unsigned long &i, const unsigned long &j) 
  {
#ifdef RANGE_CHECKING
   this->range_check(i,j);
#endif   
   return Matrixdata[M*i+j];
  }

 /// \short The access function the will be called by the read-only 
 /// (const version) round-bracket operator.
 inline T get_entry(const unsigned long &i, 
                           const unsigned long &j) const
  {
#ifdef RANGE_CHECKING
   this->range_check(i,j);
#endif  
   return Matrixdata[M*i+j];
  }

 /// Constructor to build a square n by n matrix
 DenseMatrix(const unsigned long &n);
 
 /// Constructor to build a matrix with n rows and m columns
 DenseMatrix(const unsigned long &n, const unsigned long &m);
 
 /// \short Constructor to build a matrix with n rows and m columns,
 /// with initial value initial_val
 DenseMatrix(const unsigned long &n, const unsigned long &m,
             const T &initial_val);
 
 /// Destructor, clean up the matrix data
 virtual ~DenseMatrix() {delete[] Matrixdata; Matrixdata=0;}
 
 /// Return the number of rows of the matrix
 inline unsigned long nrow() const {return N;} 

 /// Return the number of columns of the matrix
 inline  unsigned long ncol() const {return M;}
 
 /// Resize to a square nxn matrix;
 /// any values already present will be transfered
 void resize(const unsigned long &n) {resize(n,n);}
 
 /// \short Resize to a non-square n x m matrix;
 /// any values already present will be transfered
 void resize(const unsigned long &n, const unsigned long &m);
 
 /// \short Resize to a non-square n x m matrix and initialize the 
 /// new values to initial_value.
 void resize(const unsigned long &n, const unsigned long &m, 
             const T& initial_value);
 
 /// \short Initialize all values in the matrix to val.
 void initialise(const T& val)
  {for(unsigned long i=0;i<(N*M);++i) {Matrixdata[i] = val;}}
 
 /// Output function to print a matrix row-by-row to the stream outfile
 void output(std::ostream &outfile) const;
 
 /// Output function to print a matrix row-by-row to a file. Specify filename.
 void output(std::string filename) const;

 /// \short Indexed output function to print a matrix to the 
 /// stream outfile as i,j,a(i,j)
 void indexed_output(std::ostream &outfile) const;

 /// \short Indexed output function to print a matrix to a
 /// file as i,j,a(i,j). Specify filename.
 void indexed_output(std::string filename) const;

 /// \short Indexed output function to print a matrix to the 
 /// stream outfile as i,j,a(i,j) for a(i,j)!=0 only
 void sparse_indexed_output(std::ostream &outfile) const;
 
 /// \short Indexed output function to print a matrix to a 
 /// file as i,j,a(i,j) for a(i,j)!=0 only. Specify filename.
 void sparse_indexed_output(std::string filename) const;

};


///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////


//================================================================
/// Class for sparse matrices, that store only the non-zero values
/// in a linear array in memory. The details of the array indexing
/// vary depending on the storage scheme used. The MATRIX_TYPE 
/// template parameter for use in the curious recursive template 
/// pattern is included and passed directly to the base Matrix class.
//=================================================================
template <class T, class MATRIX_TYPE>
class SparseMatrix : public Matrix<T,MATRIX_TYPE>
 {
   protected:

  /// Internal representation of the matrix values, a pointer
  T* Value;
  
  /// Number of rows
  unsigned long N;

  /// Number of columns
  unsigned long M;

  /// Number of non-zero values (i.e. size of Value array)
  unsigned long Nnz;

  /// Dummy zero
  static T Zero;
  
   public:
  
  /// Default constructor
  SparseMatrix() : Value(0), N(0), M(0), Nnz(0) {}
  
  /// Copy constructor
  SparseMatrix(const SparseMatrix& source_matrix)
   {
    // Number of nonzero entries
    Nnz=source_matrix.nnz();
    
    // Number of rows
    N=source_matrix.nrow();
    
    // Number of columns
    M=source_matrix.ncol();
    
    // Values stored in C-style array
    Value = new T[Nnz];
    
    // Assign the values
    for (unsigned long i=0;i<Nnz;i++) {Value[i]=source_matrix.value()[i];}
   }
 
  /// Broken assignment operator
  void operator=(const SparseMatrix&) 
   {
    BrokenCopy::broken_assign("SparseMatrix");
   }
  
  /// Destructor, delete the memory associated with the values
  virtual ~SparseMatrix() {delete[] Value; Value=0;}
  
  /// Access to C-style value array
  T* value() {return Value;}
 
  /// Access to C-style value array (const version)
  const T* value() const {return Value;}
  
  /// Return the number of rows of the matrix
  inline unsigned long nrow() const {return N;}
  
  /// Return the number of columns of the matrix
  inline unsigned long ncol() const {return M;}
  
  /// Return the number of nonzero entries
  inline unsigned long nnz() const {return Nnz;}
  
  /// \short Indexed output function to print a matrix to the
  /// stream outfile as i,j,a(i,j) for a(i,j)!=0 only
  virtual void sparse_indexed_output(std::ostream &outfile) const
   {
    std::string error_message = 
     "SparseMatrix::sparse_indexed_output() is a virtual function.\n";
    error_message +=
     "It must be overloaded for specific sparse matrix storage formats\n";
    
    throw OomphLibError(error_message,
                        "SparseMatrix::sparse_indexed_output()",
                        OOMPH_EXCEPTION_LOCATION);
   }
  
  /// \short Indexed output function to print a matrix to a
  /// file as i,j,a(i,j) for a(i,j)!=0 only. Specify filename.
  void sparse_indexed_output(std::string filename) const
   {
    // Open file
    std::ofstream some_file;
    some_file.open(filename.c_str());
    sparse_indexed_output(some_file);
    some_file.close();
   }
  
 };






//======================================================================
/// \short A class for compressed row matrices, a sparse storage format
/// Once again the recursive template trick is used to inform that base
/// class that is should use the access functions provided in the
/// CRMatrix class.
//=====================================================================
template<class T>
class CRMatrix : public SparseMatrix<T, CRMatrix<T> >
{

  public:


 /// Default constructor
 CRMatrix() : SparseMatrix<T, CRMatrix<T> >()
  {
   Column_index=0;
   Row_start=0;
  }


 /// \short Constructor: Pass vector of values, vector of column indices,
 /// vector of row starts and number of rows and columns
 /// Number of nonzero entries is read
 /// off from value, so make sure the vector has been shrunk
 /// to its correct length.
 CRMatrix(const Vector<T>& value, const Vector<int>& column_index_,
          const Vector<int>& row_start_, 
          const unsigned long &n,
          const unsigned long &m) :
  SparseMatrix<T, CRMatrix<T> >()
  {
   Column_index=0;
   Row_start=0;
   build(value,column_index_,row_start_,n,m);
  }
 
 /// \short Copy constructor
 CRMatrix(const CRMatrix& source_matrix) : 
  SparseMatrix<T, CRMatrix<T> >(source_matrix)
  {
   //NNz, N and M are set the the copy constructor of the SparseMatrix
   //called above
   // Column indices stored in C-style array
   Column_index = new int[this->Nnz];
 
   // Assign:
   for (unsigned long i=0;i<this->Nnz;i++)
    {
     Column_index[i]=source_matrix.column_index()[i];
    }
   
   // Row start:
   Row_start = new int[this->N+1];
   
   // Assign:
   for (unsigned long i=0;i<=this->N;i++)
    {
     Row_start[i]=source_matrix.row_start()[i];
    }
  }

  /// Broken assignment operator
 void operator=(const CRMatrix&) 
  {
   BrokenCopy::broken_assign("CRMatrix");
  }

 /// Destructor, delete any allocated memory
 virtual ~CRMatrix()
  {
   delete[] Column_index; Column_index = 0;
   delete[] Row_start; Row_start = 0;
  }
 
 /// \short Access function that will be called by the read-only round-bracket
 /// operator (const)
  T get_entry(const unsigned long &i, 
                    const unsigned long &j) const
  {
#ifdef RANGE_CHECKING
   this->range_check(i,j);
#endif   
   for (long k=Row_start[i];k<Row_start[i+1];k++)
    {
     if (unsigned(Column_index[k])==j)
      {
       return this->Value[k];
      }
    }
   return this->Zero;
  }

 /// The read-write access function is deliberately broken
 T& entry(const unsigned long &i, const unsigned long &j)
  {
   std::string error_string =
    "Non-const access not provided for the CRMatrix<T> class\n";
   error_string += "It is not possible to use round-bracket access: M(i,j)\n";
   error_string += "if M is not declared as const.\n";
   error_string += 
    "The solution (albeit ugly) is to create const reference to the matrix\n";
   error_string += " const CRMatrix<T>& read_M = M;\n";
   error_string += "Then read_M(i,j) is permitted\n";

   throw OomphLibError(error_string,
                       "CRMatrix<T>::entry()",
                       OOMPH_EXCEPTION_LOCATION);

   // Dummy return
   T dummy;
   return dummy;
  }

 /// Access to C-style row_start array
 int* row_start() {return Row_start;}

 /// Access to C-style row_start array (const version)
 const int* row_start() const {return Row_start;}

 /// Access to C-style column index array
 int* column_index() {return Column_index;}

 /// Access to C-style column index array (const version)
 const int* column_index() const {return Column_index;}

 /// \short Indexed output function to print a matrix to the
 /// stream outfile as i,j,a(i,j) for a(i,j)!=0 only
 void sparse_indexed_output(std::ostream &outfile) const
  {
   std::streamsize outfile_precision = outfile.precision();
   outfile << std::setprecision(15);
   for (unsigned long i=0;i<this->N;i++)
    {
     for (long j=Row_start[i];j<Row_start[i+1];j++)
      {
       outfile << i << " " << Column_index[j] << " " 
               << this->Value[j]
               << std::endl;
      }
    }

          outfile  << std::setprecision(outfile_precision);
   // If there is no output for the last entry then output zero
   if(get_entry(this->nrow()-1, this->ncol()-1) == this->Zero)
     {
       outfile << this->nrow()-1 << " " << this->ncol()-1 << " " << this->Zero
               << std::endl;
     }
   outfile << std::setprecision(outfile_precision);
  }

 /// \short Indexed output function to print a matrix to a
 /// file as i,j,a(i,j) for a(i,j)!=0 only. Specify filename.
 void sparse_indexed_output(std::string filename) const
  {
   // Open file
   std::ofstream some_file;
   some_file.open(filename.c_str());
   sparse_indexed_output(some_file);
   some_file.close();
  }

 /// Wipe matrix data and set all values to 0.
 void clean_up_memory();

 /// \short Build matrix from compressed representation. Number of nonzero 
 /// entries is read off from value, so make sure the vector has been shrunk
 /// to its correct length. This matrix forms the storage for CRDoubleMatrices
 /// which are distributable. The argument n should be the number of local
 /// rows. The argument m is the number of columns
 void build(const Vector<T>& value, const Vector<int>& column_index,
            const Vector<int>& row_start, 
            const unsigned long &n,
            const unsigned long &m);


 /// \short Function to build matrix from pointers to arrays 
 /// which hold the row starts, column indices and non-zero values.
 /// The final two arguments are the number of rows and columns.
 /// Note that, as the name suggests, this function does not
 /// make a copy of the data pointed to by the first three arguments!
 void build_without_copy(T* value,
                         int* column_index,
                         int* row_start,
                         const unsigned long& nnz,
                         const unsigned long& n,
                         const unsigned long& m);
 
 
  protected:

 /// Column index
 int* Column_index;

 /// Start index for row
 int* Row_start;
 
};


//Forward definition for the superlu solver
class SuperLUSolver;


//=============================================================================
/// \short A class for compressed row matrices. This is a distributable 
/// object.
//=============================================================================
class CRDoubleMatrix : public Matrix<double, CRDoubleMatrix >,
                       public DoubleMatrixBase,
                       public DistributableLinearAlgebraObject
{
 
  public:

 /// Default constructor
 CRDoubleMatrix();

 /// \short Constructor: vector of values, vector of column indices,
 /// vector of row starts and number of rows and columns.
 CRDoubleMatrix(const LinearAlgebraDistribution* distribution_pt,
                const unsigned& ncol,
                const Vector<double>& value, 
                const Vector<int>& column_index,
                const Vector<int>& row_start);

 /// \short Constructor: just stores the distribution but does not build the
 /// matrix
 CRDoubleMatrix(const LinearAlgebraDistribution* distribution_pt);
 
 /// Broken copy constructor
 CRDoubleMatrix(const CRDoubleMatrix& matrix); 

 /// Broken assignment operator
 void operator=(const CRDoubleMatrix&) 
  {
   BrokenCopy::broken_assign("CRDoubleMatrix");
  }

 /// Destructor
 virtual ~CRDoubleMatrix();
 
 /// \short build method: vector of values, vector of column indices,
 /// vector of row starts and number of rows and columns.
 void build(const LinearAlgebraDistribution* distribution_pt,
              const unsigned& ncol,
              const Vector<double>& value, 
              const Vector<int>& column_index,
              const Vector<int>& row_start);
 
 /// rebuild the matrix - assembles an empty matrix will a defined distribution
 void build(const LinearAlgebraDistribution* distribution_pt);

 /// \short keeps the existing distribution and just matrix that is stored
 void build(const unsigned& ncol,
	    const Vector<double>& value,
	    const Vector<int>& column_index,
	    const Vector<int>& row_start);
 
 /// \short keeps the existing distribution and just matrix that is stored
 /// without copying the matrix data
 void build_without_copy(const unsigned& ncol,
			 const unsigned& nnz,
			 double* value,
			 int* column_index,
			 int* row_start);

 /// The contents of the matrix are redistributed to match the new
 /// distribution. In a non-MPI build this method does nothing. \n
 /// \b NOTE 1: The current distribution and the new distribution must have
 /// the same number of global rows.\n
 /// \b NOTE 2: The current distribution and the new distribution must have
 /// the same Communicator.
 void redistribute(const LinearAlgebraDistribution* const& dist_pt);

 /// \short clear
 void clear();

 /// Return the number of rows of the matrix
 inline unsigned long nrow() const
  {
    return DistributableLinearAlgebraObject::nrow();
  }
 
 /// Return the number of columns of the matrix
 inline unsigned long ncol() const
  {
   return CR_matrix.ncol();
  }

 /// \short Indexed output function to print a matrix to the 
 /// stream outfile as i,j,a(i,j) for a(i,j)!=0 only
 void sparse_indexed_output(std::ostream &outfile) const
  {
   CR_matrix.sparse_indexed_output(outfile);
  }

  /// \short Indexed output function to print a matrix to a
  /// file as i,j,a(i,j) for a(i,j)!=0 only. Specify filename.
  void sparse_indexed_output(std::string filename) const
   {
    // Open file
    std::ofstream some_file;
    some_file.open(filename.c_str());
    sparse_indexed_output(some_file);
    some_file.close();
   }


  /// \short Indexed output function to print a matrix to a
  /// file as i,j,a(i,j) for a(i,j)!=0 only. Specify filename.
  /// This uses acual global row numbers.
  void sparse_indexed_output_with_offset(std::string filename)
   {
    
    // Get offset
    unsigned first_row=distribution_pt()->first_row();

    // Open file
    std::ofstream some_file;
    some_file.open(filename.c_str());
    unsigned n=nrow_local();
    for (unsigned long i=0;i<n;i++)
     {
      for (long j=row_start()[i];j<row_start()[i+1];j++)
       {
        some_file << first_row+i << " " << column_index()[j] << " "
                  << value()[j]
                  << std::endl;
       }
     }
    some_file.close();
   }

 /// Overload the round-bracket access operator for read-only access. In a 
 /// distributed matrix i refers to the local row index. 
 inline double operator()(const unsigned long &i, 
                                 const unsigned long &j) const 
 {return CR_matrix.get_entry(i,j);}
 
 /// Access to C-style row_start array
 int* row_start() {return CR_matrix.row_start();}

 /// Access to C-style row_start array (const version)
 const int* row_start() const {return CR_matrix.row_start();}

 /// Access to C-style column index array
 int* column_index() {return CR_matrix.column_index();}

 /// Access to C-style column index array (const version)
 const int* column_index() const {return CR_matrix.column_index();}

 /// Access to C-style value array
 double* value() {return CR_matrix.value();}
 
 /// Access to C-style value array (const version)
 const double* value() const {return CR_matrix.value();}

 /// Return the number of nonzero entries
 inline unsigned long nnz() const {return CR_matrix.nnz();}
 
 /// \short LU decomposition using SuperLU if matrix is not distributed or
 /// distributed onto a single processor.
 virtual void ludecompose();

 /// \short LU back solve for given RHS
 virtual void lubksub(DoubleVector &rhs);

 /// \short Multiply the matrix by the vector x: soln=Ax
 void multiply(const DoubleVector& x, DoubleVector& soln) const;  

 /// \short Multiply the  transposed matrix by the vector x: soln=A^T x
 void multiply_transpose(const DoubleVector& x,
                         DoubleVector& soln) const;

 /// \short Function to multiply this matrix by the CRDoubleMatrix matrix_in.\n
 /// In a serial matrix, there are 4 methods available: \n
 /// Method 1: First runs through this matrix and matrix_in to find the storage
 ///           requirements for result - arrays of the correct size are 
 ///           then allocated before performing the calculation.
 ///           Minimises memory requirements but more costly. \n
 /// Method 2: Grows storage for values and column indices of result 'on the
 ///           fly' using an array of maps. Faster but more memory
 ///           intensive. \n
 /// Method 3: Grows storage for values and column indices of result 'on the
 ///           fly' using a vector of vectors. Not particularly impressive
 ///           on the platforms we tried... \n
 /// Method 4: Trilinos Epetra Matrix Matrix multiply.\n
 /// Method 5: Trilinox Epetra Matrix Matrix Mulitply (ml based) \n
 /// If Trilinos is installed then Method 4 is employed by default, otherwise
 /// Method 2 is employed by default. \n
 /// In a distributed matrix, only Trilinos Epetra Matrix Matrix multiply
 /// is available.
 void multiply(const CRDoubleMatrix& matrix_in, CRDoubleMatrix& result) const;
   
 /// \short For every row, find the maximum absolute value of the
 /// entries in this row. Set all values that are less than alpha times
 /// this maximum to zero and return the resulting matrix in
 /// reduced_matrix. Note: Diagonal entries are retained regardless
 /// of their size. 
 void matrix_reduction(const double &alpha,
                       CRDoubleMatrix& reduced_matrix);

 /// \short Access function to Serial_matrix_matrix_multiply_method, the flag
 /// which determines the matrix matrix multiplication method used for serial 
 /// matrices.
 /// Method 1: First runs through this matrix and matrix_in to find the storage
 ///           requirements for result - arrays of the correct size are 
 ///           then allocated before performing the calculation.
 ///           Minimises memory requirements but more costly. \n
 /// Method 2: Grows storage for values and column indices of result 'on the
 ///           fly' using an array of maps. Faster but more memory
 ///           intensive. \n
 /// Method 3: Grows storage for values and column indices of result 'on the
 ///           fly' using a vector of vectors. Not particularly impressive
 ///           on the platforms we tried... \n
 /// Method 4: Trilinos Epetra Matrix Matrix multiply.\n
 /// Method 5: Trilinos Epetra Matrix Matrix multiply (ML based).\n
 unsigned& serial_matrix_matrix_multiply_method() 
  { 
   return Serial_matrix_matrix_multiply_method; 
  }

 /// \short Access function to Distributed_matrix_matrix_multiply_method, the 
 /// flag which determines the matrix matrix multiplication method used for 
 /// distributed matrices.
 /// Method 1: Trilinos Epetra Matrix Matrix multiply.\n
 /// Method 2: Trilinos Epetra Matrix Matrix multiply (ML based).\n
 unsigned& distributed_matrix_matrix_multiply_method() 
  { 
   return Distributed_matrix_matrix_multiply_method; 
  }

 /// \short access function to the Built flag - indicates whether the matrix
 /// has been build - i.e. the distribution has been defined and the matrix
 /// assembled.
 bool built() const { return Built; } 

 /// \short if this matrix is distributed then a the equivalent global matrix 
 /// is built using new and returned. The calling method is responsible for the 
 /// destruction of the new matrix.
 CRDoubleMatrix* global_matrix() const;

 /// \short returns the inf-norm of this matrix
 double inf_norm() const;

 private:

 /// \short Flag to determine which matrix-matrix multiplication method is used
 /// (for serial (or global) matrices)
 unsigned Serial_matrix_matrix_multiply_method;

 /// \short Flag to determine which matrix-matrix multiplication method is used
 /// (for distributed matrices) 
 unsigned Distributed_matrix_matrix_multiply_method;

 /// Storage for the Matrix in CR Format
 CRMatrix<double> CR_matrix;

 /// \short Flag to indicate whether the matrix has been built - i.e. the 
 /// distribution has been setup AND the matrix has been assembled. 
 bool Built;
};


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


//Forward definition of the DenseLU class
class DenseLU;

//=================================================================
/// \short Class of matrices containing doubles, and stored as a 
/// DenseMatrix<double>, but with solving functionality inherited
/// from the abstract DoubleMatrix class. 
//=================================================================
class DenseDoubleMatrix : public DoubleMatrixBase,
                          public DenseMatrix<double>
{

  public:

 /// Constructor, set the default linear solver
 DenseDoubleMatrix();
 
 /// Constructor to build a square n by n matrix.
 DenseDoubleMatrix(const unsigned long &n);
 
 /// Constructor to build a matrix with n rows and m columns.
 DenseDoubleMatrix(const unsigned long &n, const unsigned long &m);

 /// \short Constructor to build a matrix with n rows and m columns,
 /// with initial value initial_val
 DenseDoubleMatrix(const unsigned long &n, const unsigned long &m,
                   const double &initial_val);

 /// Broken copy constructor
 DenseDoubleMatrix(const DenseDoubleMatrix& matrix) : 
  DoubleMatrixBase(), DenseMatrix<double>()
  {
   BrokenCopy::broken_copy("DenseDoubleMatrix");
  } 
 
 /// Broken assignment operator
 void operator=(const DenseDoubleMatrix&) 
  {
   BrokenCopy::broken_assign("DenseDoubleMatrix");
  }

 
 /// Return the number of rows of the matrix
 inline unsigned long nrow() const {return DenseMatrix<double>::nrow();}
 
 /// Return the number of columns of the matrix
 inline unsigned long ncol() const {return DenseMatrix<double>::ncol();}

 /// \short Overload the const version of the round-bracket access operator
 /// for read-only access.
 inline double operator()(const unsigned long &i, 
                                 const unsigned long &j) 
  const {return DenseMatrix<double>::get_entry(i,j);}
   
 /// \short Overload the non-const version of the round-bracket access
 /// operator for read-write access
 inline double& operator()(const unsigned long &i, const unsigned long &j) 
  {return DenseMatrix<double>::entry(i,j);}
 
 /// Destructor
 virtual ~DenseDoubleMatrix(); 
 
 /// \short LU decomposition using DenseLU (default linea solver)
 virtual void ludecompose();

 /// \short LU backsubstitution
 virtual void lubksub(DoubleVector &rhs);

 /// \short LU backsubstitution
 virtual void lubksub(Vector<double> &rhs);
 
 /// \short Determine eigenvalues and eigenvectors, using
 /// Jacobi rotations. Only for symmetric matrices. Nothing gets overwritten!
 /// - \c eigen_vect(i,j) = j-th component of i-th eigenvector.
 /// - \c eigen_val(i) is the i-th eigenvalue; same ordering as in eigenvectors
 void eigenvalues_by_jacobi(Vector<double> & eigen_val,
                            DenseMatrix<double> &eigen_vect) const;
 
 /// \short Multiply the matrix by the vector x: soln=Ax 
 void multiply(const DoubleVector &x, DoubleVector &soln) const;
 
 /// \short Multiply the  transposed matrix by the vector x: soln=A^T x
 void multiply_transpose(const DoubleVector &x,
                         DoubleVector &soln) const;

 /// \short For every row, find the maximum absolute value of the
 /// entries in this row. Set all values that are less than alpha times
 /// this maximum to zero and return the resulting matrix in
 /// reduced_matrix. Note: Diagonal entries are retained regardless
 /// of their size. 
 void matrix_reduction(const double &alpha,
                        DenseDoubleMatrix& reduced_matrix);

 /// Function to multiply this matrix by a DenseDoubleMatrix matrix_in
 void multiply(const DenseDoubleMatrix& matrix_in,
               DenseDoubleMatrix& result);
};

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////






//=================================================================
///A Rank 3 Tensor class 
//=================================================================
template <class T>
class RankThreeTensor
{

  private:

 /// Private internal representation  as pointer to data
 T* Tensordata;
 
 /// 1st Tensor dimension
 unsigned N;

 /// 2nd Tensor dimension
 unsigned M;

 /// 3rd Tensor dimension
 unsigned P;

 /// \short Range check to catch when an index is out of bounds, if so, it
 /// issues a warning message and dies by throwing an \c OomphLibError
 void range_check(const unsigned long& i, 
                  const unsigned long& j,
                  const unsigned long& k) const
  {
   if (i>=N)
    {
     std::ostringstream error_message;
     error_message << "Range Error: i=" << i << " is not in the range (0," 
                   << N-1 << ")." << std::endl;
   
     throw OomphLibError(error_message.str(),
                         "RankThreeTensor::range_check()",
                         OOMPH_EXCEPTION_LOCATION);
    }
   else if (j>=M)
    {
     std::ostringstream error_message;
     error_message << "Range Error: j=" << j << " is not in the range (0," 
                   << M-1 << ")." << std::endl;

      throw OomphLibError(error_message.str(),
                         "RankThreeTensor::range_check()",
                         OOMPH_EXCEPTION_LOCATION);
    }
   else if (k>=P)
    {
     std::ostringstream error_message;
     error_message << "Range Error: k=" << k << " is not in the range (0," 
                   << P-1 << ")." << std::endl;

      throw OomphLibError(error_message.str(),
                         "RankThreeTensor::range_check()",
                         OOMPH_EXCEPTION_LOCATION);
    }
  }


  public:

 /// Empty constructor
 RankThreeTensor(): Tensordata(0), N(0), M(0), P(0) {}

 /// Copy constructor: Deep copy
 RankThreeTensor(const RankThreeTensor& source_tensor)
  {
   // Set row and column lengths
   N=source_tensor.nindex1();
   M=source_tensor.nindex2();
   P=source_tensor.nindex3();
   // Assign space for the data
   Tensordata = new T[N*M*P];
   // Copy the data across from the other matrix
   for(unsigned i=0;i<N;i++)
    {
     for(unsigned j=0;j<M;j++)
      {
       for(unsigned k=0;k<P;k++)
        {
         Tensordata[P*(M*i + j) +k] = source_tensor(i,j,k);
        }
      }
    }
  }

 /// Copy assignement 
 RankThreeTensor& operator=(const RankThreeTensor& source_tensor) 
  {
   // Don't create a new matrix if the assignement is the identity
   if (this != & source_tensor)
    {
     // Check row and column length
     unsigned long n=source_tensor.nindex1();
     unsigned long m=source_tensor.nindex2();
     unsigned long p=source_tensor.nindex3();
     //Resie the tensor to be the same size as the old tensor
     if ( (N!=n) || (M!=m) || (P!=p) ) {resize(n,m,p);}
     
     // Copy entries across from the other matrix
     for (unsigned long i=0;i<N;i++)
      {
       for (unsigned long j=0;j<M;j++)
        {
         for(unsigned long k=0;k<P;k++)
          {
           (*this)(i,j,k) = source_tensor(i,j,k);
          }
        }
      }
    }
   // Return reference to object itself (i.e. de-reference this pointer)
   return *this;
  }


 /// One parameter constructor produces a cubic nxnxn tensor
 RankThreeTensor(const unsigned long &n) 
  {
   // Set row and column lengths
   N=n; M=n; P=n;
   // Assign space for the n rows
   Tensordata = new T[N*M*P];
   //Initialise to zero if required
#ifdef OOMPH_INITIALISE_DENSE_MATRICES
   initialise(T(0));
#endif
  }

 /// Three parameter constructor, general non-square tensor
 RankThreeTensor(const unsigned long &n_index1, const unsigned long &n_index2,
                 const unsigned long &n_index3)
  {
   // Set row and column lengths
   N=n_index1; M=n_index2; P=n_index3;
   // Assign space for the n rows
   Tensordata = new T[N*M*P];
   //Initialise to zero if required
#ifdef OOMPH_INITIALISE_DENSE_MATRICES
   initialise(T(0));
#endif
  }


 /// Three parameter constructor, general non-square tensor
 RankThreeTensor(const unsigned long &n_index1, const unsigned long &n_index2,
                 const unsigned long &n_index3, const T &initial_val)
  {
   // Set row and column lengths
   N=n_index1; M=n_index2; P=n_index3;
   // Assign space for the n rows
   Tensordata = new T[N*M*P];
   //Initialise to the initial value
   initialise(initial_val);
  }

 /// Destructor: delete the pointers
 virtual ~RankThreeTensor() {delete[] Tensordata; Tensordata = 0;}

 /// Resize to a square nxnxn tensor
 void resize(const unsigned long &n) {resize(n,n,n);}
 
 /// Resize to a general tensor
 void resize(const unsigned long &n_index1, const unsigned long &n_index2,
             const unsigned long &n_index3)
  {
   //If the sizes have not changed do nothing
   if((n_index1==N) && (n_index2==M) && (n_index3==P)) {return;}
   // Store old sizes
   unsigned long n_old=N, m_old=M, p_old=P;
   // Reassign the sizes
   N=n_index1; M=n_index2; P=n_index3;
   // Store triple pointer to old matrix data
   T* temp_tensor = Tensordata;
   // Re-create Tensordata in new size
   Tensordata = new T[N*M*P];
#ifdef OOMPH_INITIALISE_DENSE_MATRICES
   initialise(T(0));
#endif
   // Transfer values
   unsigned long n_copy, m_copy, p_copy;
   n_copy = std::min(n_old,n_index1);
   m_copy = std::min(m_old,n_index2);
   p_copy = std::min(p_old,n_index3);
   // If matrix has values, transfer them to new matrix
   // Loop over rows
   for (unsigned long i=0;i<n_copy;i++)
    {
     // Loop over columns
     for (unsigned long j=0;j<m_copy;j++)
      {
       // Loop over columns
       for (unsigned long k=0;k<p_copy;k++)
        {
         // Transfer values from temp_tensor
         Tensordata[M*P*i + P*j + k] = 
          temp_tensor[m_old*p_old*i + p_old*j + k];
        }
      }
    }
   // Now kill storage for old tensor
   delete[] temp_tensor;
  }

 /// Resize to a general tensor
 void resize(const unsigned long &n_index1, const unsigned long &n_index2,
             const unsigned long &n_index3, const T &initial_value)
  {
   //If the sizes have not changed do nothing
   if((n_index1==N) && (n_index2==M) && (n_index3==P)) {return;}
   // Store old sizes
   unsigned long n_old=N, m_old=M, p_old=P;
   // Reassign the sizes
   N=n_index1; M=n_index2; P=n_index3;
   // Store triple pointer to old matrix data
   T* temp_tensor = Tensordata;
   // Re-create Tensordata in new size
   Tensordata = new T[N*M*P];
   //Initialise the newly allocated storage
   initialise(initial_value);

   // Transfer values
   unsigned long n_copy, m_copy, p_copy;
   n_copy = std::min(n_old,n_index1);
   m_copy = std::min(m_old,n_index2);
   p_copy = std::min(p_old,n_index3);
   // If matrix has values, transfer them to new matrix
   // Loop over rows
   for (unsigned long i=0;i<n_copy;i++)
    {
     // Loop over columns
     for (unsigned long j=0;j<m_copy;j++)
      {
       // Loop over columns
       for (unsigned long k=0;k<p_copy;k++)
        {
         // Transfer values from temp_tensor
         Tensordata[M*P*i + P*j + k] = 
          temp_tensor[m_old*p_old*i + p_old*j + k];
        }
      }
    }
   // Now kill storage for old tensor
   delete[] temp_tensor;
  }

 /// \short Initialise all values in the tensor to val
 void initialise(const T &val)
  {for(unsigned long i=0;i<(N*M*P);++i) {Tensordata[i] = val;}}

 /// Return the range of index 1 of the tensor
 unsigned long nindex1() const {return N;}
 
 /// Return the range of index 2 of the tensor
 unsigned long nindex2() const {return M;}

 /// Return the range of index 3 of the tensor
 unsigned long nindex3() const {return P;}

 /// Overload the round brackets to give access as a(i,j,k)
 inline T &operator()(const unsigned long &i, const unsigned long &j,
                      const unsigned long &k) 
  {
#ifdef RANGE_CHECKING
   this->range_check(i,j,k);
#endif   
   return Tensordata[P*(M*i + j) + k];
  }

 /// Overload a const version for read-only access as a(i,j,k)
 inline T operator()(const unsigned long &i, const unsigned long &j,
                            const unsigned long &k) const
  {
#ifdef RANGE_CHECKING
   this->range_check(i,j,k);
#endif  
   return Tensordata[P*(M*i + j) + k];
  }
 
};  

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////



//=================================================================
///A Rank 4 Tensor class 
//=================================================================
template <class T>
class RankFourTensor
{

  private:

 /// Private internal representation  as pointer to data
 T* Tensordata;
 
 /// 1st Tensor dimension
 unsigned N;

 /// 2nd Tensor dimension
 unsigned M;

 /// 3rd Tensor dimension
 unsigned P;
 
 /// 4th Tensor dimension
 unsigned Q;
 
 /// \short Range check to catch when an index is out of bounds, if so, it
 /// issues a warning message and dies by throwing an \c OomphLibError
 void range_check(const unsigned long& i, 
                  const unsigned long& j,
                  const unsigned long& k,
                  const unsigned long& l) const
  {
   if (i>=N)
    {
     std::ostringstream error_message;
     error_message << "Range Error: i=" << i << " is not in the range (0," 
                   << N-1 << ")." << std::endl;
   
     throw OomphLibError(error_message.str(),
                         "RankFourTensor::range_check()",
                         OOMPH_EXCEPTION_LOCATION);
    }
   else if (j>=M)
    {
     std::ostringstream error_message;
     error_message << "Range Error: j=" << j << " is not in the range (0," 
                   << M-1 << ")." << std::endl;

      throw OomphLibError(error_message.str(),
                         "RankFourTensor::range_check()",
                         OOMPH_EXCEPTION_LOCATION);
    }
   else if (k>=P)
    {
     std::ostringstream error_message;
     error_message << "Range Error: k=" << k << " is not in the range (0," 
                   << P-1 << ")." << std::endl;

      throw OomphLibError(error_message.str(),
                         "RankFourTensor::range_check()",
                         OOMPH_EXCEPTION_LOCATION);
    }
   else if (l>=Q)
    {
     std::ostringstream error_message;
     error_message << "Range Error: l=" << l << " is not in the range (0," 
                   << Q-1 << ")." << std::endl;

      throw OomphLibError(error_message.str(),
                         "RankFourTensor::range_check()",
                         OOMPH_EXCEPTION_LOCATION);
    }
  }
  public:

 /// Empty constructor
 RankFourTensor(): Tensordata(0), N(0), M(0), P(0), Q(0) {}

 /// Copy constructor: Deep copy
 RankFourTensor(const RankFourTensor& source_tensor)
  {
   // Set row and column lengths
   N=source_tensor.nindex1();
   M=source_tensor.nindex2();
   P=source_tensor.nindex3();
   Q=source_tensor.nindex4();

   // Assign space for the data
   Tensordata = new T[N*M*P*Q];

   // Copy the data across from the other matrix
   for(unsigned i=0;i<N;i++)
    {
     for(unsigned j=0;j<M;j++)
      {
       for(unsigned k=0;k<P;k++)
        {
         for(unsigned l=0;l<Q;l++)
          {
         Tensordata[Q*(P*(M*i + j) +k)+l] = source_tensor(i,j,k,l);
          }
        }
      }
    }
  }
 
 /// Copy assignement 
 RankFourTensor& operator=(const RankFourTensor& source_tensor) 
  {
   // Don't create a new matrix if the assignement is the identity
   if (this != & source_tensor)
    {
     // Check row and column length
     unsigned long n=source_tensor.nindex1();
     unsigned long m=source_tensor.nindex2();
     unsigned long p=source_tensor.nindex3();
     unsigned long q=source_tensor.nindex4();
     //Resize the tensor to be the same size as the old tensor
     if ( (N!=n) || (M!=m) || (P!=p) || (Q!=q) ) {resize(n,m,p,q);}
     
     // Copy entries across from the other matrix
     for (unsigned long i=0;i<N;i++)
      {
       for (unsigned long j=0;j<M;j++)
        {
         for(unsigned long k=0;k<P;k++)
          {
           for(unsigned long l=0;l<Q;l++)
            {
             (*this)(i,j,k,l) = source_tensor(i,j,k,l);
            }
          }
        }
      }
    }
   // Return reference to object itself (i.e. de-reference this pointer)
   return *this;
  }


 /// One parameter constructor produces a  nxnxnxn tensor
 RankFourTensor(const unsigned long &n) 
  {
   // Set row and column lengths
   N=n; M=n; P=n; Q=n;
   // Assign space for the n rows
   Tensordata = new T[N*M*P*Q];
   //Initialise to zero if required
#ifdef OOMPH_INITIALISE_DENSE_MATRICES
   initialise(T(0));
#endif
  }
 
 /// Four parameter constructor, general non-square tensor
 RankFourTensor(const unsigned long &n_index1, const unsigned long &n_index2,
                const unsigned long &n_index3, const unsigned long &n_index4)
  {
   // Set row and column lengths
   N=n_index1; M=n_index2; P=n_index3; Q=n_index4;
   // Assign space for the n rows
   Tensordata = new T[N*M*P*Q];
   //Initialise to zero if required
#ifdef OOMPH_INITIALISE_DENSE_MATRICES
   initialise(T(0));
#endif
  }


 /// Four parameter constructor, general non-square tensor
 RankFourTensor(const unsigned long &n_index1, const unsigned long &n_index2,
                const unsigned long &n_index3, const unsigned long &n_index4, 
                const T &initial_val)
  {
   // Set row and column lengths
   N=n_index1; M=n_index2; P=n_index3; Q=n_index4;
   // Assign space for the n rows
   Tensordata = new T[N*M*P*Q];
   //Initialise to the initial value
   initialise(initial_val);
  }

 /// Destructor: delete the pointers
 virtual ~RankFourTensor() {delete[] Tensordata; Tensordata = 0;}

 /// Resize to a square nxnxnxn tensor
 void resize(const unsigned long &n) {resize(n,n,n,n);}
 
 /// Resize to a general tensor
 void resize(const unsigned long &n_index1, const unsigned long &n_index2,
             const unsigned long &n_index3, const unsigned long &n_index4)
  {
   //If the sizes have not changed do nothing
   if((n_index1==N) && (n_index2==M) && (n_index3==P) && (n_index4==Q)) 
    {return;}
   // Store old sizes
   unsigned long n_old=N, m_old=M, p_old=P, q_old=Q;
   // Reassign the sizes
   N=n_index1; M=n_index2; P=n_index3; Q=n_index4;
   // Store pointer to old matrix data
   T* temp_tensor = Tensordata;
   // Re-create Tensordata in new size
   Tensordata = new T[N*M*P*Q];
#ifdef OOMPH_INITIALISE_DENSE_MATRICES
   initialise(T(0));
#endif
   // Transfer values
   unsigned long n_copy, m_copy, p_copy, q_copy;
   n_copy = std::min(n_old,n_index1);
   m_copy = std::min(m_old,n_index2);
   p_copy = std::min(p_old,n_index3);
   q_copy = std::min(q_old,n_index4);
   // If matrix has values, transfer them to new matrix
   // Loop over rows
   for (unsigned long i=0;i<n_copy;i++)
    {
     // Loop over columns
     for (unsigned long j=0;j<m_copy;j++)
      {
       // Loop over columns
       for (unsigned long k=0;k<p_copy;k++)
        {
         // Loop over columns
         for (unsigned long l=0;l<q_copy;l++)
          {
           // Transfer values from temp_tensor
           Tensordata[Q*(M*P*i + P*j + k) +l] = 
            temp_tensor[q_old*(m_old*p_old*i + p_old*j + k)+ l];
          }
        }
      }
    }
   // Now kill storage for old tensor
   delete[] temp_tensor;
  }

 /// Resize to a general tensor
 void resize(const unsigned long &n_index1, const unsigned long &n_index2,
             const unsigned long &n_index3, const unsigned long &n_index4,
             const T &initial_value)
  {
   //If the sizes have not changed do nothing
   if((n_index1==N) && (n_index2==M) && (n_index3==P) && (n_index4==Q))
    {return;}
   // Store old sizes
   unsigned long n_old=N, m_old=M, p_old=P, q_old=Q;
   // Reassign the sizes
   N=n_index1; M=n_index2; P=n_index3; Q=n_index4;
   // Store triple pointer to old matrix data
   T* temp_tensor = Tensordata;
   // Re-create Tensordata in new size
   Tensordata = new T[N*M*P*Q];
   //Initialise the newly allocated storage
   initialise(initial_value);

   // Transfer values
   unsigned long n_copy, m_copy, p_copy, q_copy;
   n_copy = std::min(n_old,n_index1);
   m_copy = std::min(m_old,n_index2);
   p_copy = std::min(p_old,n_index3);
   q_copy = std::min(q_old,n_index4);
   // If matrix has values, transfer them to new matrix
   // Loop over rows
   for (unsigned long i=0;i<n_copy;i++)
    {
     // Loop over columns
     for (unsigned long j=0;j<m_copy;j++)
      {
       // Loop over columns
       for (unsigned long k=0;k<p_copy;k++)
        {
         // Loop over columns
         for (unsigned long l=0;l<q_copy;l++)
          {
           // Transfer values from temp_tensor
           Tensordata[Q*(M*P*i + P*j + k) +l] = 
            temp_tensor[q_old*(m_old*p_old*i + p_old*j + k)+ l];
          }
        }
      }
    }
   // Now kill storage for old tensor
   delete[] temp_tensor;
  }
 
 /// \short Initialise all values in the tensor to val
 void initialise(const T &val)
  {for(unsigned long i=0;i<(N*M*P*Q);++i) {Tensordata[i] = val;}}
 
 /// Return the range of index 1 of the tensor
 unsigned long nindex1() const {return N;}

 /// Return the range of index 2 of the tensor
 unsigned long nindex2() const {return M;}

 /// Return the range of index 3 of the tensor
 unsigned long nindex3() const {return P;}

 /// Return the range of index 4 of the tensor
 unsigned long nindex4() const {return Q;}
 
 /// Overload the round brackets to give access as a(i,j,k,l)
 inline T &operator()(const unsigned long &i, const unsigned long &j,
                      const unsigned long &k, const unsigned long &l) 
  {
#ifdef RANGE_CHECKING
   this->range_check(i,j,k,l);
#endif  
   return Tensordata[Q*(P*(M*i + j) + k)+l];
  }
 
 /// Overload a const version for read-only access as a(i,j,k,l)
 inline T operator()(const unsigned long &i, 
                            const unsigned long &j,
                            const unsigned long &k, 
                            const unsigned long &l) const
  {
#ifdef RANGE_CHECKING
   this->range_check(i,j,k,l);
#endif
   return Tensordata[Q*(P*(M*i + j) + k)+l];
  }
 
 /// \short Direct access to internal storage of data in flat-packed C-style 
 /// column-major format. WARNING: Only for experienced users. Only
 /// use this if raw speed is of the essence, as in the solid mechanics 
 /// problems.
 inline T& raw_direct_access(const unsigned long &i)
  {return Tensordata[i];}

 /// \short Direct access to internal storage of data in flat-packed C-style 
 /// column-major format. WARNING: Only for experienced users. Only
 /// use this if raw speed is of the essence, as in the solid mechanics 
 /// problems.
 inline const T &raw_direct_access(const unsigned long &i) const
  {return Tensordata[i];}

 /// \short Caculate the offset in flat-packed C-style, column-major format,
 /// required for a given i,j. WARNING: Only for experienced users. Only
 /// use this if raw speed is of the essence, as in the solid mechanics 
 /// problems.
 unsigned offset(const unsigned long &i,
                 const unsigned long &j) const
  {return (Q*(P*(M*i + j) + 0) + 0);}

};  


//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////


//=================================================================
///A Rank 5 Tensor class 
//=================================================================
template <class T>
class RankFiveTensor
{

  private:

 /// Private internal representation  as pointer to data
 T* Tensordata;
 
 /// 1st Tensor dimension
 unsigned N;
 
 /// 2nd Tensor dimension
 unsigned M;
 
 /// 3rd Tensor dimension
 unsigned P;
 
 /// 4th Tensor dimension
 unsigned Q;
 
 /// 5th Tensor dimension
 unsigned R;
 
 /// \short Range check to catch when an index is out of bounds, if so, it
 /// issues a warning message and dies by throwing an \c OomphLibError
 void range_check(const unsigned long& i, 
                  const unsigned long& j,
                  const unsigned long& k,
                  const unsigned long& l,
                  const unsigned long& m) const
  {
   if (i>=N)
    {
     std::ostringstream error_message;
     error_message << "Range Error: i=" << i << " is not in the range (0," 
                   << N-1 << ")." << std::endl;
     
     throw OomphLibError(error_message.str(),
                         "RankFiveTensor::range_check()",
                         OOMPH_EXCEPTION_LOCATION);
    }
   else if (j>=M)
    {
     std::ostringstream error_message;
     error_message << "Range Error: j=" << j << " is not in the range (0," 
                   << M-1 << ")." << std::endl;

      throw OomphLibError(error_message.str(),
                         "RankFiveTensor::range_check()",
                         OOMPH_EXCEPTION_LOCATION);
    }
   else if (k>=P)
    {
     std::ostringstream error_message;
     error_message << "Range Error: k=" << k << " is not in the range (0," 
                   << P-1 << ")." << std::endl;

      throw OomphLibError(error_message.str(),
                         "RankFiveTensor::range_check()",
                         OOMPH_EXCEPTION_LOCATION);
    }
   else if (l>=Q)
    {
     std::ostringstream error_message;
     error_message << "Range Error: l=" << l << " is not in the range (0," 
                   << Q-1 << ")." << std::endl;
     
     throw OomphLibError(error_message.str(),
                         "RankFiveTensor::range_check()",
                         OOMPH_EXCEPTION_LOCATION);
    }
   else if (m>=R)
    {
     std::ostringstream error_message;
     error_message << "Range Error: m=" << m << " is not in the range (0," 
                   << R-1 << ")." << std::endl;
     
     throw OomphLibError(error_message.str(),
                         "RankFiveTensor::range_check()",
                         OOMPH_EXCEPTION_LOCATION);
    }
  }

  public:

 /// Empty constructor
 RankFiveTensor(): Tensordata(0), N(0), M(0), P(0), Q(0), R(0) {}
 
 /// Copy constructor: Deep copy
 RankFiveTensor(const RankFiveTensor& source_tensor)
  {
   // Set row and column lengths
   N=source_tensor.nindex1();
   M=source_tensor.nindex2();
   P=source_tensor.nindex3();
   Q=source_tensor.nindex4();
   R=source_tensor.nindex5();
   
   // Assign space for the data
   Tensordata = new T[N*M*P*Q*R];
   
   // Copy the data across from the other matrix
   for(unsigned i=0;i<N;i++)
    {
     for(unsigned j=0;j<M;j++)
      {
       for(unsigned k=0;k<P;k++)
        {
         for(unsigned l=0;l<Q;l++)
          {
           for(unsigned m=0;m<R;m++)
            {
             Tensordata[R*(Q*(P*(M*i + j) +k)+l)+m] = source_tensor(i,j,k,l,m);
            }
          }
        }
      }
    }
  }
 
 /// Copy assignement 
 RankFiveTensor& operator=(const RankFiveTensor& source_tensor) 
  {
   // Don't create a new matrix if the assignement is the identity
   if (this != & source_tensor)
    {
     // Check row and column length
     unsigned long n=source_tensor.nindex1();
     unsigned long m=source_tensor.nindex2();
     unsigned long p=source_tensor.nindex3();
     unsigned long q=source_tensor.nindex4();
     unsigned long r=source_tensor.nindex5();
     //Resize the tensor to be the same size as the old tensor
     if ( (N!=n) || (M!=m) || (P!=p) || (Q!=q)|| (R!=r) ) {resize(n,m,p,q,r);}
     
     // Copy entries across from the other matrix
     for (unsigned long i=0;i<N;i++)
      {
       for (unsigned long j=0;j<M;j++)
        {
         for(unsigned long k=0;k<P;k++)
          {
           for(unsigned long l=0;l<Q;l++)
            {
             for(unsigned long m=0;m<R;m++)
              {
               (*this)(i,j,k,l,m) = source_tensor(i,j,k,l,m);
              }
            }
          }
        }
      }
    }
   // Return reference to object itself (i.e. de-reference this pointer)
   return *this;
  }
 
 
 /// One parameter constructor produces a  nxnxnxnxn tensor
 RankFiveTensor(const unsigned long &n) 
  {
   // Set row and column lengths
   N=n; M=n; P=n; Q=n; R=n;
   // Assign space for the n rows
   Tensordata = new T[N*M*P*Q*R];
   //Initialise to zero if required
#ifdef OOMPH_INITIALISE_DENSE_MATRICES
   initialise(T(0));
#endif
  }
 
 /// Four parameter constructor, general non-square tensor
 RankFiveTensor(const unsigned long &n_index1, const unsigned long &n_index2,
                const unsigned long &n_index3, const unsigned long &n_index4,
                const unsigned long &n_index5)
  {
   // Set row and column lengths
   N=n_index1; M=n_index2; P=n_index3; Q=n_index4; R=n_index5;
   // Assign space for the n rows
   Tensordata = new T[N*M*P*Q*R];
   //Initialise to zero if required
#ifdef OOMPH_INITIALISE_DENSE_MATRICES
   initialise(T(0));
#endif
  }
 

 /// Four parameter constructor, general non-square tensor
 RankFiveTensor(const unsigned long &n_index1, const unsigned long &n_index2,
                const unsigned long &n_index3, const unsigned long &n_index4, 
                const unsigned long &n_index5, const T &initial_val)
  {
   // Set row and column lengths
   N=n_index1; M=n_index2; P=n_index3; Q=n_index4; R=n_index5;
   // Assign space for the n rows
   Tensordata = new T[N*M*P*Q*R];
   //Initialise to the initial value
   initialise(initial_val);
  }
 
 /// Destructor: delete the pointers
 virtual ~RankFiveTensor() {delete[] Tensordata; Tensordata = 0;}
 
 /// Resize to a square nxnxnxn tensor
 void resize(const unsigned long &n) {resize(n,n,n,n,n);}
 
 /// Resize to a general tensor
 void resize(const unsigned long &n_index1, const unsigned long &n_index2,
             const unsigned long &n_index3, const unsigned long &n_index4,
             const unsigned long &n_index5)
  {
   //If the sizes have not changed do nothing
   if((n_index1==N) && (n_index2==M) && (n_index3==P) && (n_index4==Q) && 
      (n_index5==R)) 
    {return;}
   // Store old sizes
   unsigned long n_old=N, m_old=M, p_old=P, q_old=Q, r_old=R;
   // Reassign the sizes
   N=n_index1; M=n_index2; P=n_index3; Q=n_index4; R=n_index5;
   // Store pointer to old matrix data
   T* temp_tensor = Tensordata;
   // Re-create Tensordata in new size
   Tensordata = new T[N*M*P*Q*R];
#ifdef OOMPH_INITIALISE_DENSE_MATRICES
   initialise(T(0));
#endif
   // Transfer values
   unsigned long n_copy, m_copy, p_copy, q_copy, r_copy;
   n_copy = std::min(n_old,n_index1);
   m_copy = std::min(m_old,n_index2);
   p_copy = std::min(p_old,n_index3);
   q_copy = std::min(q_old,n_index4);
   r_copy = std::min(r_old,n_index5);
   // If matrix has values, transfer them to new matrix
   // Loop over rows
   for (unsigned long i=0;i<n_copy;i++)
    {
     // Loop over columns
     for (unsigned long j=0;j<m_copy;j++)
      {
       // Loop over columns
       for (unsigned long k=0;k<p_copy;k++)
        {
         // Loop over columns
         for (unsigned long l=0;l<q_copy;l++)
          {
           // Loop over columns
           for (unsigned long m=0;m<r_copy;m++)
            {
             // Transfer values from temp_tensor
             Tensordata[R*(Q*(M*P*i + P*j + k) +l) +m] = 
              temp_tensor[r_old*(q_old*(m_old*p_old*i + p_old*j + k)+ l)+ m];
            }
          }
        }
      }
    }
   // Now kill storage for old tensor
   delete[] temp_tensor;
  }

 /// Resize to a general tensor
 void resize(const unsigned long &n_index1, const unsigned long &n_index2,
             const unsigned long &n_index3, const unsigned long &n_index4,
             const unsigned long &n_index5, const T &initial_value)
  {
   //If the sizes have not changed do nothing
   if((n_index1==N) && (n_index2==M) && (n_index3==P) && (n_index4==Q) &&
      (n_index5==R))
    {return;}
   // Store old sizes
   unsigned long n_old=N, m_old=M, p_old=P, q_old=Q, r_old=R;
   // Reassign the sizes
   N=n_index1; M=n_index2; P=n_index3; Q=n_index4; R=n_index5;
   // Store triple pointer to old matrix data
   T* temp_tensor = Tensordata;
   // Re-create Tensordata in new size
   Tensordata = new T[N*M*P*Q*R];
   //Initialise the newly allocated storage
   initialise(initial_value);

   // Transfer values
   unsigned long n_copy, m_copy, p_copy, q_copy, r_copy;
   n_copy = std::min(n_old,n_index1);
   m_copy = std::min(m_old,n_index2);
   p_copy = std::min(p_old,n_index3);
   q_copy = std::min(q_old,n_index4);
   r_copy = std::min(r_old,n_index5);
   // If matrix has values, transfer them to new matrix
   // Loop over rows
   for (unsigned long i=0;i<n_copy;i++)
    {
     // Loop over columns
     for (unsigned long j=0;j<m_copy;j++)
      {
       // Loop over columns
       for (unsigned long k=0;k<p_copy;k++)
        {
         // Loop over columns
         for (unsigned long l=0;l<q_copy;l++)
          {
           // Loop over columns
           for (unsigned long m=0;m<r_copy;m++)
            {
             // Transfer values from temp_tensor
             Tensordata[R*(Q*(M*P*i + P*j + k) +l) + m] = 
            temp_tensor[r_old*(q_old*(m_old*p_old*i + p_old*j + k)+ l) +m];
            }
          }
        }
      }
    }
   // Now kill storage for old tensor
   delete[] temp_tensor;
  }
 
 /// \short Initialise all values in the tensor to val
 void initialise(const T &val)
  {for(unsigned long i=0;i<(N*M*P*Q*R);++i) {Tensordata[i] = val;}}
 
 /// Return the range of index 1 of the tensor
 unsigned long nindex1() const {return N;}

 /// Return the range of index 2 of the tensor
 unsigned long nindex2() const {return M;}

 /// Return the range of index 3 of the tensor
 unsigned long nindex3() const {return P;}

 /// Return the range of index 4 of the tensor
 unsigned long nindex4() const {return Q;}
 
 /// Return the range of index 5 of the tensor
 unsigned long nindex5() const {return R;}

 /// Overload the round brackets to give access as a(i,j,k,l,m)
 inline T &operator()(const unsigned long &i, const unsigned long &j,
                      const unsigned long &k, const unsigned long &l,
                      const unsigned long &m) 
  {
#ifdef RANGE_CHECKING
   this->range_check(i,j,k,l,m);
#endif  
   return Tensordata[R*(Q*(P*(M*i + j) + k) +l) +m];
  }
 
 /// Overload a const version for read-only access as a(i,j,k,l,m)
 inline T operator()(const unsigned long &i, 
                            const unsigned long &j,
                            const unsigned long &k, 
                            const unsigned long &l,
                            const unsigned long &m) const
  {
#ifdef RANGE_CHECKING
   this->range_check(i,j,k,l,m);
#endif
   return Tensordata[R*(Q*(P*(M*i + j) + k) +l) +m];
  }
 
 /// \short Direct access to internal storage of data in flat-packed C-style 
 /// column-major format. WARNING: Only for experienced users. Only
 /// use this if raw speed is of the essence, as in the solid mechanics 
 /// problems.
 inline T &raw_direct_access(const unsigned long &i)
  {return Tensordata[i];}


 /// \short Direct access to internal storage of data in flat-packed C-style 
 /// column-major format. WARNING: Only for experienced users. Only
 /// use this if raw speed is of the essence, as in the solid mechanics 
 /// problems.
 inline const T &raw_direct_access(const unsigned long &i) const
  {return Tensordata[i];}

 /// \short Caculate the offset in flat-packed Cy-style, column-major format,
 /// required for a given i,j,k. WARNING: Only for experienced users. Only
 /// use this if raw speed is of the essence, as in the solid mechanics 
 /// problems.
 unsigned offset(const unsigned long &i,
                 const unsigned long &j,
                 const unsigned long &k) const
  {return (R*(Q*(P*(M*i + j) + k) + 0 ) + 0);}


};  





//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////

//=======================================================================
/// \short A class for compressed column matrices: a sparse matrix format
/// The class is passed as the MATRIX_TYPE paramater so that the base
/// class can use the specific access functions in the round-bracket
/// operator.
//=======================================================================
template<class T>
class CCMatrix : public SparseMatrix<T, CCMatrix<T> >
{

  public:

 /// Default constructor
 CCMatrix() : SparseMatrix<T, CCMatrix<T> >()
  {
   Row_index=0;
   Column_start=0;
  }


 /// \short Constructor: Pass vector of values, vector of row indices,
 /// vector of column starts and number of rows (can be suppressed
 /// for square matrices). Number of nonzero entries is read
 /// off from value, so make sure the vector has been shrunk
 /// to its correct length.
 CCMatrix(const Vector<T>& value, const Vector<int>& row_index_,
          const Vector<int>& column_start_,
          const unsigned long &n,
          const unsigned long &m) : SparseMatrix<T, CCMatrix<T> >()
  {
   Row_index=0;
   Column_start=0;
   build(value,row_index_,column_start_,n,m);
  }

 
 /// \short Copy constructor
 CCMatrix(const CCMatrix& source_matrix) : 
  SparseMatrix<T, CCMatrix<T> >(source_matrix)
  {
   //NNz, N and M are set the the copy constructor of the SparseMatrix
   //called above

   // Row indices stored in C-style array
   Row_index = new int[this->Nnz];
   
   // Assign:
   for (unsigned long i=0;i<this->Nnz;i++)
    {
     Row_index[i]=source_matrix.row_index()[i];
    }
   
   // Column start:
   Column_start = new int[this->M+1];
   
   // Assign:
   for (unsigned long i=0;i<=this->M;i++)
    {
     Column_start[i]=source_matrix.column_start()[i];
    }
  }

 /// Broken assignment operator
 void operator=(const CCMatrix&) 
  {
   BrokenCopy::broken_assign("CCMatrix");
  }

 
 /// Destructor, delete any allocated memory
 virtual ~CCMatrix()
  {
   delete[] Row_index; Row_index = 0;
   delete[] Column_start; Column_start = 0;
  }
 
 /// \short Access function that will be called by the read-only round-bracket
 /// operator (const)
 T get_entry(const unsigned long &i, const unsigned long &j) const
  {
#ifdef RANGE_CHECKING
   this->range_check(i,j);
#endif   
   for (long k=Column_start[j];k<Column_start[j+1];k++)
    {
     if (unsigned(Row_index[k])==i)
      {
       return this->Value[k];
      }
    }
   return this->Zero;
  }

 /// Read-write access is not permitted for these matrices and is
 /// deliberately broken.
 T& entry(const unsigned long &i, const unsigned long &j)
  {
   std::string error_string =
    "Non-const access not provided for the CCMatrix<T> class\n";
   error_string += "It is not possible to use round-bracket access: M(i,j)\n";
   error_string += "if M is not declared as const.\n";
   error_string += 
    "The solution (albeit ugly) is to create const reference to the matrix\n";
   error_string += " const CCMatrix<T>& read_M = M;\n";
   error_string += "Then read_M(i,j) is permitted\n";

   throw OomphLibError(error_string,
                       "CCMatrix<T>::entry()",
                       OOMPH_EXCEPTION_LOCATION);

   // Dummy return
   T dummy;
   return dummy;
  }
 
 /// Access to C-style column_start array
 int* column_start() {return Column_start;}

 /// Access to C-style column_start array (const version)
 const int* column_start() const {return Column_start;}

 /// Access to C-style row index array
 int* row_index() {return Row_index;}

 /// Access to C-style row index array (const version)
 const int* row_index() const {return Row_index;}

 /// \short Indexed output function to print a matrix to the
 /// stream outfile as i,j,a(i,j) for a(i,j)!=0 only
 void sparse_indexed_output(std::ostream &outfile) const
  {
   for (unsigned long j=0;j<this->N;j++)
    {
     for (long k=Column_start[j];k<Column_start[j+1];k++)
      {
       outfile << Row_index[k] <<  " " << j
               <<  " " << this->Value[k] << std::endl;
      }
    }

   // If there is no output for the last entry then output zero
   if(get_entry(this->nrow()-1, this->ncol()-1) == this->Zero)
     {
       outfile << this->nrow()-1 << " " << this->ncol()-1 << " " << this->Zero
               << std::endl;
     }
  }


 /// \short Indexed output function to print a matrix to a
 /// file as i,j,a(i,j) for a(i,j)!=0 only. Specify filename.
 void sparse_indexed_output(std::string filename) const
  {
   // Open file
   std::ofstream some_file;
   some_file.open(filename.c_str());
   sparse_indexed_output(some_file);
   some_file.close();
  }


 /// Wipe matrix data and set all values to 0.
 void clean_up_memory();


 /// \short Build matrix from compressed representation.
 /// Number of nonzero entries is read
 /// off from value, so make sure the vector has been shrunk
 /// to its correct length. 
 void build(const Vector<T>& value, const Vector<int>& row_index,
            const Vector<int>& column_start, 
            const unsigned long &n,
            const unsigned long &m);

 /// \short Function to build matrix from pointers to arrays 
 /// which hold the column starts, row indices and non-zero values.
 /// The final parameters specifies the number of rows and columns.
 /// Note that, as the name suggests, this function does not
 /// make a copy of the data pointed to by the first three arguments!
 void build_without_copy(T* value,
                         int* row_index,
                         int* column_start,
                         const unsigned long &nnz,
                         const unsigned long &n,
                         const unsigned long &m);


  protected:

 /// Row index
 int* Row_index;

 /// Start index for column
 int* Column_start;
 
};

///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////


//=================================================================
/// \short A class for compressed column matrices that store doubles
//=================================================================
class CCDoubleMatrix : public DoubleMatrixBase,
                       public CCMatrix<double>
{
 
  public:

 /// Default constructor
 CCDoubleMatrix();
  
 /// \short Constructor: Pass vector of values, vector of row indices,
 /// vector of column starts and number of rows (can be suppressed
 /// for square matrices). Number of nonzero entries is read
 /// off from value, so make sure the vector has been shrunk
 /// to its correct length.
 CCDoubleMatrix(const Vector<double>& value,
                const Vector<int>& row_index_,
                const Vector<int>& column_start_,
                const unsigned long &n,
                const unsigned long &m);
 
 /// Broken copy constructor
 CCDoubleMatrix(const CCDoubleMatrix& matrix) : DoubleMatrixBase(),
  CCMatrix<double>()
  {
   BrokenCopy::broken_copy("CCDoubleMatrix");
  } 
 
 /// Broken assignment operator
 void operator=(const CCDoubleMatrix&) 
  {
   BrokenCopy::broken_assign("CCDoubleMatrix");
  }

 /// Destructor: Kill the LU factors if they have been setup.
 virtual ~CCDoubleMatrix();

  /// Return the number of rows of the matrix
 inline unsigned long nrow() const {return CCMatrix<double>::nrow();}
 
 /// Return the number of columns of the matrix
 inline unsigned long ncol() const {return CCMatrix<double>::ncol();}

 /// \short Overload the round-bracket access operator to provide
 /// read-only (const) access to the data
 inline double operator()(const unsigned long &i, 
                                 const unsigned long &j) 
  const {return CCMatrix<double>::get_entry(i,j);}
 
 /// \short LU decomposition using SuperLU
 virtual void ludecompose();

 /// \short LU back solve for given RHS
 virtual void lubksub(DoubleVector &rhs);

 /// \short Multiply the matrix by the vector x: soln=Ax
 void multiply(const DoubleVector &x, DoubleVector &soln) const;

 /// \short Multiply the  transposed matrix by the vector x: soln=A^T x
 void multiply_transpose(const DoubleVector &x,
                         DoubleVector &soln) const;


 /// \short Function to multiply this matrix by the CCDoubleMatrix matrix_in
 /// The multiplication method used can be selected using the flag
 /// Matrix_matrix_multiply_method. By default Method 2 is used.
 /// Method 1: First runs through this matrix and matrix_in to find the storage
 ///           requirements for result - arrays of the correct size are 
 ///           then allocated before performing the calculation.
 ///           Minimises memory requirements but more costly.
 /// Method 2: Grows storage for values and column indices of result 'on the
 ///           fly' using an array of maps. Faster but more memory
 ///           intensive.
 /// Method 3: Grows storage for values and column indices of result 'on the
 ///           fly' using a vector of vectors. Not particularly impressive
 ///           on the platforms we tried...
 void multiply(const CCDoubleMatrix& matrix_in, CCDoubleMatrix& result);
  
  
 /// \short For every row, find the maximum absolute value of the
 /// entries in this row. Set all values that are less than alpha times
 /// this maximum to zero and return the resulting matrix in
 /// reduced_matrix. Note: Diagonal entries are retained regardless
 /// of their size. 
 void matrix_reduction(const double &alpha,
                       CCDoubleMatrix& reduced_matrix);
 
 /// \short Access function to Matrix_matrix_multiply_method, the flag
 /// which determines the matrix matrix multiplication method used.
 /// Method 1: First runs through this matrix and matrix_in to find the storage
 ///           requirements for result - arrays of the correct size are 
 ///           then allocated before performing the calculation.
 ///           Minimises memory requirements but more costly.
 /// Method 2: Grows storage for values and column indices of result 'on the
 ///           fly' using an array of maps. Faster but more memory
 ///           intensive.
 /// Method 3: Grows storage for values and column indices of result 'on the
 ///           fly' using a vector of vectors. Not particularly impressive
 ///           on the platforms we tried...
 unsigned& matrix_matrix_multiply_method() 
  { 
   return Matrix_matrix_multiply_method; 
  }
 
  private:
 
 /// Flag to determine which matrix-matrix multiplication method is used.
 unsigned Matrix_matrix_multiply_method;

};




/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////



//============================================================================
/// Constructor to build a square n by n matrix
//============================================================================
template<class T>
DenseMatrix<T>::DenseMatrix(const unsigned long &n)
{
 // Set row and column lengths
 N=n; M=n;
 // Assign space for the n rows
 Matrixdata = new T[n*n];
 //Initialise to zero if required
#ifdef OOMPH_INITIALISE_DENSE_MATRICES
 initialise(T(0));
#endif
}


//============================================================================
/// Constructor to build a matrix with n rows and m columns
//============================================================================
template<class T>
DenseMatrix<T>::DenseMatrix(const unsigned long &n, 
                            const unsigned long &m)
{
 // Set row and column lengths
 N=n; M=m;
 // Assign space for the n rows
 Matrixdata = new T[n*m];
#ifdef OOMPH_INITIALISE_DENSE_MATRICES
 initialise(T(0));
#endif
}

//============================================================================
/// \short Constructor to build a matrix with n rows and m columns,
/// with initial value initial_val
//============================================================================
template<class T>
DenseMatrix<T>::DenseMatrix(const unsigned long &n, const unsigned long &m,
                            const T &initial_val)
{
 // Set row and column lengths
 N=n; M=m;
 // Assign space for the n rows
 Matrixdata = new T[n*m];
 initialise(initial_val);
}


//============================================================================
/// \short Resize to a non-square n_row x m_col matrix,
/// where any values already present will be transfered.
//============================================================================
template<class T>
void DenseMatrix<T>::resize(const unsigned long &n,
                            const unsigned long &m)
{
 //If the sizes are the same, do nothing
 if((n==N) && (m==M)) {return;}
 // Store old sizes
 unsigned long n_old=N, m_old=M;
 // Reassign the sizes
 N=n; M=m;
 // Store double pointer to old matrix data
 T* temp_matrix = Matrixdata;

 // Re-create Matrixdata in new size
 Matrixdata = new T[n*m];
 //Initialise to zero
#ifdef OOMPH_INITIALISE_DENSE_MATRICES 
 initialise(T(0));
#endif

 // Transfer previously existing values
 unsigned long n_copy, m_copy;
 n_copy = std::min(n_old,n); m_copy = std::min(m_old,m);

 // If matrix has values, transfer them to new matrix
 // Loop over rows
 for(unsigned long i=0;i<n_copy;i++)
  {
   // Loop over columns
   for (unsigned long j=0;j<m_copy;j++)
    {
     // Transfer values from temp_matrix
     Matrixdata[m*i+j] = temp_matrix[m_old*i+j];
    }
  }
 
 // Now kill storage for old matrix
 delete[] temp_matrix;
}



//============================================================================
/// \short Resize to a non-square n_row x m_col matrix and initialize the 
/// new entries to specified value.
//============================================================================
template<class T>
void DenseMatrix<T>::resize(const unsigned long &n,
                            const unsigned long &m, 
                            const T &initial_value)
{
 //If the size is not changed, just return
 if((n==N) && (m==M)) {return;}
 // Store old sizes
 unsigned long n_old=N, m_old=M;
 // Reassign the sizes
 N=n; M=m;
 // Store double pointer to old matrix data
 T* temp_matrix = Matrixdata;
 // Re-create Matrixdata in new size
 Matrixdata = new T[n*m];
 // Assign initial value (will use the newly allocated data)
 initialise(initial_value);
 
 // Transfering values
 unsigned long n_copy, m_copy;
 n_copy = std::min(n_old,n); m_copy = std::min(m_old,m);
 // If matrix has values, transfer them to temp_matrix
 // Loop over rows
 for (unsigned long i=0;i<n_copy;i++)
  {
   // Loop over columns
   for (unsigned long j=0;j<m_copy;j++)
    {
     // Transfer values to temp_matrix
     Matrixdata[m*i+j] = temp_matrix[m_old*i+j];
    }
  }

 // Now kill storage for old matrix
 delete[] temp_matrix;
}



//============================================================================
/// Output function to print a matrix row-by-row to the stream outfile
//============================================================================
template<class T>
void DenseMatrix<T>::output(std::ostream &outfile) const
{
 //Loop over the rows
 for(unsigned i=0;i<N;i++)
  {
   //Loop over the columne
   for(unsigned j=0;j<M;j++)
    {
     outfile << (*this)(i,j) << " ";
    }
   //Put in a newline
   outfile << std::endl;
  }
}



//============================================================================
/// Output function to print a matrix row-by-row to a file. Specify filename.
//============================================================================
template<class T>
void DenseMatrix<T>::output(std::string filename) const
{
 // Open file
 std::ofstream some_file;
 some_file.open(filename.c_str());
   
 output(some_file);
 some_file.close();
}



//============================================================================
/// Indexed output as i,j,a(i,j)
//============================================================================
template<class T>
void DenseMatrix<T>::indexed_output(std::ostream &outfile) const
{
 //Loop over the rows
 for(unsigned i=0;i<N;i++)
  {
   //Loop over the columns
   for(unsigned j=0;j<M;j++)
    {
     outfile << i << " " << j << " " << (*this)(i,j) << std::endl;
    }
  }
}



//============================================================================
/// \short Indexed output function to print a matrix to a
/// file as i,j,a(i,j). Specify filename.
//============================================================================
template<class T>
void DenseMatrix<T>::indexed_output(std::string filename) const
{
 // Open file
 std::ofstream some_file;
 some_file.open(filename.c_str());
 indexed_output(some_file);
 some_file.close();
}



//============================================================================
/// Sparse indexed output as i,j,a(i,j) for a(i,j)!=0 only
//============================================================================
template<class T>
void DenseMatrix<T>::sparse_indexed_output(std::ostream &outfile) const
{
 //Loop over the rows
 for(unsigned i=0;i<N;i++)
  {
   //Loop over the column
   for(unsigned j=0;j<M;j++)
    {
     if ((*this)(i,j)!=T(0))
      {
       outfile << i << " " << j << " " << (*this)(i,j) << std::endl;
      }
    }
  }

 // If there is no output for the last entry then output zero
 if(get_entry(this->nrow()-1, this->ncol()-1) == T(0))
   {
     outfile << this->nrow()-1 << " " << this->ncol()-1 << " " << T(0)
             << std::endl;
   }
}



//============================================================================
/// \short Indexed output function to print a matrix to a 
/// file as i,j,a(i,j) for a(i,j)!=0 only. Specify filename.
//============================================================================
template<class T>
void DenseMatrix<T>::sparse_indexed_output(std::string filename) const
{
 // Open file
 std::ofstream some_file;
 some_file.open(filename.c_str());
 sparse_indexed_output(some_file);
 some_file.close();
}



////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////


//=============================================================================
/// Wipe matrix data and set all values to 0.
//=============================================================================
template<class T>
void CCMatrix<T>::clean_up_memory()
{
 // delete any previously allocated  storage
 if (this->Value!=0)
 {
  delete[] this->Value;
  this->Value=0;
 }
 if (this->Row_index!=0)
 {
  delete[] this->Row_index;
  this->Row_index=0;
 }
 if (this->Column_start!=0)
 {
  delete[] this->Column_start;
  this->Column_start=0;
 }
 this->Nnz=0;
 this->N=0;
 this->M=0;
}



//=============================================================================
/// Build matrix from compressed representation.
/// Note that, as the name suggests, this function does not
/// make a copy of the data pointed to by the first three arguments!
//=============================================================================
template<class T>
void CCMatrix<T>::build_without_copy(T* value,
                                     int* row_index,
                                     int* column_start,
                                     const unsigned long& nnz,
                                     const unsigned long& n,
                                     const unsigned long& m)
{
 // Number of nonzero entries
 this->Nnz=nnz;

 // Number of rows
 this->N=n;

 // Number of columns
 this->M=m;

 // delete any previously allocated  storage
 if(this->Value!=0) {delete[] this->Value;}
 if(this->Row_index!=0) {delete[] this->Row_index;}
 if(this->Column_start!=0) {delete[] this->Column_start;}

 // set Value
 this->Value = value;

 // set Row_index
 this->Row_index = row_index;

 // set Column_start
 this->Column_start = column_start;

}


//===================================================================
/// Build matrix from compressed representation.
/// Number of nonzero entries is read
/// off from value, so make sure the vector has been shrunk
/// to its correct length. 
//===================================================================
template<class T>
void CCMatrix<T>::build(const Vector<T>& value, 
                        const Vector<int>& row_index_,
                        const Vector<int>& column_start_, 
                        const unsigned long &n,
                        const unsigned long &m)
{
 
#ifdef PARANOID
 if (value.size()!=row_index_.size())
  {
   std::ostringstream error_message;
   error_message 
    << "length of value " << value.size() 
    << " and row_index vectors " << row_index_.size() <<" should match " 
    << std::endl;

   throw OomphLibError(error_message.str(),
                       "CCMatrix::build()",
                       OOMPH_EXCEPTION_LOCATION);
  }
#endif
 
 // Number of nonzero entries
 this->Nnz = value.size();
 
 //Number of rows
 this->N = n;

 // Number of columns
 this->M = m;
 
 //We need to delete any previously allocated  storage
 if(this->Value!=0) {delete[] this->Value;}
 if(this->Row_index!=0) {delete[] this->Row_index;}
 if(this->Column_start!=0) {delete[] this->Column_start;}

 // Values stored in C-style array
 this->Value = new T[this->Nnz];
 
 // Row indices stored in C-style array
 this->Row_index = new int[this->Nnz];
 
 // Assign:
 for (unsigned long i=0;i<this->Nnz;i++)
  {
   this->Value[i]=value[i];
   this->Row_index[i]=row_index_[i];
  }
 
 // Column start:
 //Find the size and aollcate
 unsigned long n_column_start = column_start_.size();
 this->Column_start = new int[n_column_start];
 
 // Assign:
 for (unsigned long i=0;i<n_column_start;i++)
  {
   this->Column_start[i]=column_start_[i];
  }
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////



//=============================================================================
/// Wipe matrix data and set all values to 0.
//=============================================================================
template<class T>
void CRMatrix<T>::clean_up_memory()
{
 // delete any previously allocated  storage
 if (this->Value!=0)
 {
  delete[] this->Value;
  this->Value=0;
 }
 if (this->Column_index!=0)
 {
  delete[] this->Column_index;
  this->Column_index=0;
 }
 if (this->Row_start!=0)
 {
  delete[] this->Row_start;
  this->Row_start=0;
 }
 this->Nnz=0;
 this->N=0;
 this->M=0;
}



//=============================================================================
/// Function to build a CRMatrix from pointers to arrays which hold the
/// row starts, column indices and non-zero values
/// Note that, as the name suggests, this function does not
/// make a copy of the data pointed to by the first three arguments!
//=============================================================================
template<class T>
void CRMatrix<T>::build_without_copy(T* value,
                                     int* column_index_,
                                     int* row_start_,
                                     const unsigned long& nnz,
                                     const unsigned long& n,
                                     const unsigned long& m)
{
 // Number of nonzero entries
 this->Nnz = nnz;
 
 // Number of rows
 this->N = n;
 
 // Number of columns
 this->M = m;

 // delete any previously allocated  storage
 if(this->Value!=0) {delete[] this->Value;}
 if(this->Column_index!=0) {delete[] this->Column_index;}
 if(this->Row_start!=0) {delete[] this->Row_start;}

 // set Value
 this->Value = value;

 // set Column_index
 this->Column_index = column_index_;

 // set Row_start
 this->Row_start = row_start_;
}



//=================================================================
/// Build matrix from compressed representation.
/// Number of nonzero entries is read
/// off from value, so make sure the vector has been shrunk
/// to its correct length. The optional final
/// parameter specifies the number of columns. If it is not specified
/// the matrix is assumed to be quadratic.
//=================================================================
template<class T>
void CRMatrix<T>::build(const Vector<T>& value, 
                        const Vector<int>& column_index_,
                        const Vector<int>& row_start_,
                        const unsigned long &n,
                        const unsigned long &m)
{
#ifdef PARANOID
    if(value.size() != column_index_.size())
      {
	std::ostringstream error_message;
	error_message << "Must have the same number of values and column indices,"
		      << "we have " << value.size() << " values and "
		      << column_index_.size() << " column inidicies."
		      << std::endl;
	throw OomphLibError(error_message.str(),"CRMatrix<T>::build",
			    OOMPH_EXCEPTION_LOCATION);
      }
#endif
 // Number of nonzero entries
 this->Nnz = value.size();
 
 // Number of rows
 this->N = n;
 
 // Number of columns
 this->M = m;
 
 //We need to delete any previously allocated  storage
 if(this->Value!=0) {delete[] this->Value;}
 if(this->Column_index!=0) {delete[] this->Column_index;}
 if(this->Row_start!=0) {delete[] this->Row_start;}

 // Values stored in C-style array
 this->Value = new T[this->Nnz];
 
 // Column indices stored in C-style array
 this->Column_index = new int[this->Nnz];
 
 // Assign:
 for (unsigned long i=0;i<this->Nnz;i++)
  {
   this->Value[i]=value[i];
   this->Column_index[i]=column_index_[i];
  }
 
 // Row start:
 // Find the size and allocate
 unsigned long n_row_start = row_start_.size();
 this->Row_start = new int[n_row_start];
 
 // Assign:
 for (unsigned long i=0;i<n_row_start;i++)
  {
   this->Row_start[i]=row_start_[i];
  } 
}


//=================================================================
/// \short Dummy zero
//=================================================================
template<class T,class MATRIX_TYPE>
 T SparseMatrix<T,MATRIX_TYPE>::Zero=T(0);



//======================================================================
/// Class for a matrix of the form M = S + G + H + ... where S is the main
/// matrix and G,H etc. are matrices of size S or smaller.  This may be useful
/// if, for example, G,H etc. are subblocks of M that must be stored in a
/// different format to S.

/// Maps mut be provided which gives a map from the rows/cols of the "main"
/// matrix to the rows/cols of each of the added matrices.
//======================================================================
class SumOfMatrices : public DoubleMatrixBase,
  public Matrix<double,SumOfMatrices>
{

 private:


  typedef std::map<long unsigned, long unsigned> IndexMap;

  /// Pointer to the matrix which we are adding the others to
  DoubleMatrixBase* Main_matrix_pt;

  /// List of pointers to the matrices that are added to the main matrix
  Vector<DoubleMatrixBase*> Added_matrix_pt;

  /// \short List of maps from the row numbers of the main matrix to the added matrix
  /// row numbers.
  Vector<IndexMap* > Main_to_individual_rows_pt;

  /// \short List of maps from the col numbers of the main matrix to the added matrix
  /// col numbers.
  Vector<IndexMap* > Main_to_individual_cols_pt;

  /// Should we delete the sub matrices when destructor is called?
  Vector<unsigned> Should_delete_added_matrix;

  /// \short Should we delete the main matrix when destructor is called? Default is
  /// no.
  bool Should_delete_main_matrix;

 public:

  /// Default constructor
 SumOfMatrices()
   : Main_matrix_pt(0), Added_matrix_pt(0),
    Main_to_individual_rows_pt(0), Main_to_individual_cols_pt(0),
    Should_delete_added_matrix(0), Should_delete_main_matrix(0) {}

  /// Constructor taking a pointer to the main matrix as input.
   SumOfMatrices(DoubleMatrixBase* main_matrix_pt)
   : Main_matrix_pt(main_matrix_pt), Added_matrix_pt(0),
    Main_to_individual_rows_pt(0), Main_to_individual_cols_pt(0),
    Should_delete_added_matrix(0), Should_delete_main_matrix(0) {}

  /// Broken copy constructor
  SumOfMatrices(const SumOfMatrices& matrix)
    {BrokenCopy::broken_copy("SumOfMatrices");}

  /// Broken assignment operator
  void operator=(const SumOfMatrices&)
    {BrokenCopy::broken_assign("SumOfMatrices");}

  /// Destructor: delete matrices as instructed by Should_delete_added_matrix vector
  virtual ~SumOfMatrices()
    {
      for(unsigned i_matrix=0; i_matrix<Added_matrix_pt.size(); i_matrix++)
	{
	  if(Should_delete_added_matrix[i_matrix] == 1)
	    delete Added_matrix_pt[i_matrix];
        }

      if(Should_delete_main_matrix)
	delete Main_matrix_pt;
    }

  /// Access to the main matrix
  const DoubleMatrixBase* main_matrix_pt() const {return Main_matrix_pt;}
  DoubleMatrixBase*& main_matrix_pt() {return Main_matrix_pt;}

  /// \short Set the main matrix to be deleted by the destructor of the SumOfMatrices
  /// (default is to not delete it).
  void set_delete_main_matrix()
  {Should_delete_main_matrix = true;}

  /// \short Output the matrix in sparse format. Note that this is going to be
  /// slow because we have to check every entry of every matrix for non-zeros.
  void sparse_indexed_output(std::ostream &outfile) const
  {
    for (unsigned long i=0; i<nrow(); i++)
      {
        for (unsigned long j=0; j<ncol(); j++)
          {
            double entry = operator()(i,j);
            // Output if non-zero entry
            if(entry != 0.0)
              {
                outfile << i << " " << j << " " << entry
                        << std::endl;
              }
          }
      }

   // If there is no output for the last entry then output zero
   if(operator()(this->nrow()-1, this->ncol()-1) == 0.0)
     {
       outfile << this->nrow()-1 << " " << this->ncol()-1 << " 0"
               << std::endl;
     }
  }

  /// \short Output the matrix in sparse format to a file. Note that this is
  /// going to be slow because we have to check every entry of every matrix
  /// for non-zeros.
  void sparse_indexed_output(const std::string &outfile) const
  {
    // Open file
    std::ofstream some_file;
    some_file.open(outfile.c_str());
    sparse_indexed_output(some_file);
    some_file.close();
    sparse_indexed_output(outfile);
  }


  /// \short Get a list of row/col indices and total entry for non-zeros in the
  /// matrix. e.g. for use as input to other matrix classes. Warning this is
  /// SLOW! for sparse matrices.
  void get_as_indices(Vector<int>& row, Vector<int>& col,
                       Vector<double>& values)
  {
    row.clear(); col.clear(); values.clear();

    for (int i=0; i<int(nrow()); i++)
      {
        for (int j=0; j<int(ncol()); j++)
          {
            double entry = operator()(i,j);
            // Output if non-zero entry
            if(entry != 0.0)
              {
                row.push_back(i);
                col.push_back(j);
                values.push_back(entry);
              }
          }
      }
  }

  /// \short Add a new matrix to the sum by giving a matrix pointer and a mapping from
  /// the main matrix numbering to the new matrix numbering.
  void add_matrix(DoubleMatrixBase* added_matrix_pt_in,
                  IndexMap* const main_to_individual_rows_pt,
                  IndexMap* const main_to_individual_cols_pt,
                  bool should_delete_matrix=false)
  {
#ifdef RANGE_CHECKING
    if (main_to_individual_rows_pt->size() > added_matrix_pt_in->nrow())
      {
        throw OomphLibError("Row mapping size should be less than or equal to nrow (less than if it is a sparse matrix and there are some empty rows.",
                            "SumOfMatrices::add_matrix",
                            OOMPH_EXCEPTION_LOCATION);
      }

    if (main_to_individual_cols_pt->size() > added_matrix_pt_in->ncol())
      {
        throw OomphLibError("Col mapping size should be less than or equal to ncol (less than if it is a sparse matrix and there are some empty cols.",
                            "SumOfMatrices::add_matrix",
                            OOMPH_EXCEPTION_LOCATION);
      }
#endif

    Added_matrix_pt.push_back(added_matrix_pt_in);
    Main_to_individual_rows_pt.push_back(main_to_individual_rows_pt);
    Main_to_individual_cols_pt.push_back(main_to_individual_cols_pt);
    Should_delete_added_matrix.push_back(unsigned(should_delete_matrix));
  }

  /// Access functions
  inline DoubleMatrixBase* added_matrix_pt(const unsigned& i) const
  {return Added_matrix_pt[i];}

  /// Return the number of rows of the total matrix (equal to that of the first
  /// matrix).
  inline unsigned long nrow() const
  {
#ifdef PARANOID
    if(Main_matrix_pt==0)
      {
        OomphLibError("Main_matrix_pt not set","SumOfMatrices::nrow()",
                      OOMPH_EXCEPTION_LOCATION);
      }
#endif
    return Main_matrix_pt->nrow();
}

  /// \short Return the number of columns of the total matrix (equal to that of the
  /// first matrix).
  inline unsigned long ncol() const
  {
#ifdef PARANOID
    if(Main_matrix_pt==0)
      {
        OomphLibError("Main_matrix_pt not set","SumOfMatrices::nrow()",
                      OOMPH_EXCEPTION_LOCATION);
      }
#endif
    return Main_matrix_pt->ncol();
  }

  /// Return the number of matrices in the sum
  inline unsigned n_added_matrix() const {return Added_matrix_pt.size();}

  /// \short Multiply: just call multiply on each of the matrices and add up the
  /// results (with appropriate bookeeping of the relative positions).
  void multiply(const DoubleVector &x, DoubleVector &soln) const;

  /// \short Broken operator() because it does not make sense to return
  /// anything by reference.
  double& entry(const unsigned long& i, const unsigned long& j) const
  {
    throw OomphLibError("Broken write to entry: it does not make sense to write to a sum, you must write to one of the component matrices.",
                        "non-constant SumOfMatrices::operator()",
                        OOMPH_EXCEPTION_LOCATION);
  }

  /// Access function to get the total value of entries in position (i,j).
  double operator()(const unsigned long &i,
                    const unsigned long &j) const
  {
    // Get contributions from all matrices
    double sum = main_matrix_pt()->operator()(i,j);
    for(unsigned i_matrix=0; i_matrix<n_added_matrix(); i_matrix++)
      {
        IndexMap::iterator local_row_it
          = Main_to_individual_rows_pt[i_matrix]->find(i);
        IndexMap::iterator local_col_it
          = Main_to_individual_cols_pt[i_matrix]->find(j);

        if((local_row_it != Main_to_individual_rows_pt[i_matrix]->end())
           && (local_col_it != Main_to_individual_cols_pt[i_matrix]->end()))
          {
            sum += added_matrix_pt(i_matrix)
              ->operator()(local_row_it->second,local_col_it->second);
          }
      }

    return sum;
  }

  /// \short Dummy overload of a pure virtual function. I'm not sure how best to
  /// implement this and I don't think I'll ever need it.
  virtual void multiply_transpose(const DoubleVector &x,
                                  DoubleVector &soln)const
  {
        std::ostringstream error_msg;
        error_msg << "Function not yet implemented.";
        throw OomphLibError(error_msg.str(),
                            "SumOfMatrices::multiply_transpose",
                            OOMPH_EXCEPTION_LOCATION);

        // Possible implementations (not really thought through):
        // - just call multiply transpose on submatrices?
        // - do something funny with switching row and column maps?
  }

};

}
#endif




