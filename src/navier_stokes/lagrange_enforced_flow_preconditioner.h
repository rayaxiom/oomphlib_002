//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//           Version 0.90. August 3, 2009.
//LIC// 
//LIC// Copyright (C) 2006-2009 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
#ifndef OOMPH_LAGRANGE_ENFORCED_FLOW_PRECONDITIONERS_HEADER
#define OOMPH_LAGRANGE_ENFORCED_FLOW_PRECONDITIONERS_HEADER


// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif


// oomphlib headers
#include "../generic/matrices.h"
#include "../generic/assembly_handler.h"
#include "../generic/problem.h"
#include "../generic/block_preconditioner.h"
#include "../generic/preconditioner.h"
#include "../generic/SuperLU_preconditioner.h"
#include "../generic/matrix_vector_product.h"
#include "navier_stokes_elements.h"
#include "refineable_navier_stokes_elements.h"
#include "navier_stokes_preconditioners.h"


namespace oomph
{
//=============================================================================
/// \short The preconditioner for the Lagrange multiplier constrained
/// Navier-Stokes equations. The velocity components are constrained by
/// Lagrange multiplier, which are applied via OOMPH-LIB's FACE elements.
/// \n\n
/// A Vector of meshes is taken, each mesh contains a different type of
/// block preconditionable element. Each element must not only classify it's 
/// own degrees of freedom but also the associated dof from the 'bulk' element.
/// \n
/// The first mesh in the Vector Meshes_pts is assumed to be the 'bulk' mesh.
/// The rest are assumed to contain FACEELMENTS applying the required 
/// constraint.
/// \n
/// Thus the most general block structure (in 3D) is: \n
/// \n
///  0 1 2 3   4 5 6 7  8  ..x   x+0 x+1 x+2 x+3 x+4 \n
/// [u v w p] [u v w l1 l2 ...] [u   v   w   l1  l2 ...] ... \n
///   Bulk       Surface 1             Surface 2         ... \n
/// \n
/// where the dof types in [] are the dof types in each mesh.
/// It is assumed that in all surface mesh (after the bulk mesh), the first
/// spatial dimension number of dof types are the constrained velocity.
/// \n\n
/// Consider the case of imposing parallel outflow (3 constrained velocity
/// dof types and 2 lagrange multiplier dof types) and tangential flow (3
/// constrained velocity dof types and 1 lagrange multiplier dof type)
/// along two different boundaries in 3D. The resulting natural block dof
/// type structure is: \n
/// [0 1 2 3] [4  5  6   7   8 ] [9  10 11 12 ]\n
/// [u v w p] [up vp wp Lp1 Lp2] [ut vt wt Lt1]\n
/// \n
/// Given that we know the spatial dimension of the problem, this information
/// can be conveniently stored in a Vector N_doftype_in_mesh = [4, 5, 4]. This
/// Vector will be used to re-order the dof types to group together the
/// velocity, pressure, then lagrange dof types like so: \n
/// \n
///  0 4  9  1 5  10  2 6  11    3    7   8  12   \n
/// [u up ut v vp vt  w wp wt ] [p] [Lp1 Lp2 Lt1] \n
///
///    0 4  9  1 5  10  2 6  11  3  7   8  12   \n
///    u up ut v vp vt  w wp wt  p Lp1 Lp2 Lt1  \n
///  ..... this is too hard to do without Latex....
///
/// We use the preconditioner in the form... check my first year report...
/// 
/// Giving rise to the blocked Jacobian:
/// F G^t
///      L
/// D   
///  L
/// 
/// Here F is the momemtum block, G the discrete gradient operator,
/// and D the discrete divergence operator. (For unstabilised elements, 
/// we have D = G^T and in much of the literature the divergence matrix is 
/// denoted by B.) The L blocks
//=============================================================================
class LagrangeEnforcedflowPreconditioner
  : public BlockPreconditioner<CRDoubleMatrix>
{
  public:


  /// Constructor - sets the defaults for control flags
  LagrangeEnforcedflowPreconditioner():BlockPreconditioner<CRDoubleMatrix>()
  {
    // Set default preconditioners
    Navier_stokes_preconditioner_pt = 0;

    // flag to indicate whether the default w preconditioner is used
    Using_superlu_w_preconditioner = true;

    // flag to indicate to use SuperLU or not.
    Using_superlu_ns_preconditioner = true;

    // flag to indicate LSC preconditioner
    Use_default_norm_of_f_scaling = true;
    Scaling_sigma = 0.0;

    N_doftypes = 0;
    N_lagrange_doftypes = 0;
    N_fluid_doftypes = 0;

    N_velocity_doftypes = 0;

    Fluid_block_size = 0;
    Pressure_block_size = 0;
    Velocity_block_size = 0;

    Doc_time = false;

    Doc_prec = false;

    Doc_info_pt = 0;

    Label = "";

    Use_diagonal_w_block = true;

    Mapping_info_calculated = false;
  }

  /// destructor
  virtual ~LagrangeEnforcedflowPreconditioner()
  {
    this->clean_up_memory();
  }

  /// Broken copy constructor
  LagrangeEnforcedflowPreconditioner (const LagrangeEnforcedflowPreconditioner&)
  {
    BrokenCopy::broken_copy("LagrangeEnforcedflowPreconditioner");
  }

  /// Broken assignment operator
  void operator=(const LagrangeEnforcedflowPreconditioner&)
  {
    BrokenCopy::broken_assign(" LagrangeEnforcedflowPreconditioner");
  }

  /// Setup method for the LagrangeEnforcedflowPreconditioner.
  void setup(Problem* problem_pt, DoubleMatrixBase* matrix_pt);

  /// \short Get the infinity norm of a matrix.
  ///  The matrix may be composed of several matrices.
  void get_inf_norm(DenseMatrix<CRDoubleMatrix* > &matrix_pt,
                    double &max_row_value);


  /// Add a scalar to each of the diagonal entry of a matrix.
  void add_scaling_to_diag(double &Scaling, CRDoubleMatrix *&block_pt);

  /// Extract the diagonal entries of a matrix.
  void get_diag(CRDoubleMatrix *&block_pt, Vector<double>& diag);

  /// Element-wise addition of two matrices.
  void add_matrices(CRDoubleMatrix *&block_pt1, CRDoubleMatrix *&block_pt2);

  /// Use the diagonal approximation for the W block.
  void use_diagonal_w_block() {Use_diagonal_w_block = true;}

  /// Use block diagonal W block.
  void use_block_diagonal_w_block() {Use_diagonal_w_block  = false;}

  ///Enable documentation of time
  void enable_doc_prec() {Doc_prec = true;}

  ///Disable documentation of time
  void disable_doc_prec() {Doc_prec = false;}

  ///Enable documentation of time
  void enable_doc_time() {Doc_time = true;}

  ///Disable documentation of time
  void disable_doc_time() {Doc_time = false;}

  /// \short Apply the preconditioner.
  /// r is the residual (rhs), z will contain the solution.
  void preconditioner_solve(const DoubleVector& r, DoubleVector& z)
  {

    // Counter for the current linear solver iteration.
    // This is used when dumping the rhs block vector,
    // we only want the first Newton Step.
    unsigned curr_its = 0;

    if(Doc_prec)
    {
      string newton_step_counter = "NS"
        + to_string(Doc_info_pt->current_nnewton_step());

      curr_its = static_cast<IterativeLinearSolver*>
        (problem_pt()->linear_solver_pt())->iterations();

      string its_counter = "i" + to_string(curr_its);

      Label = Doc_info_pt->label() + newton_step_counter
        + its_counter;

      // Dump out the block rhs if  it is the first Newton Iteration.
      if(curr_its==0)
      {
        DoubleVector x; // Will contain the re-ordered rhs
        this->get_block_ordered_preconditioner_vector(r,x);
        x.output("rhsx_" + to_string(Label));
      }
    }

    // Working vectors.
    DoubleVector temp_vec;
    DoubleVector another_temp_vec;
    DoubleVector yet_another_temp_vec;

    // First we solve all the w blocks:
    // Loop through all of the Lagrange multipliers
    for(unsigned l_i = 0; l_i < N_lagrange_doftypes; l_i++)
    {
      // Get the block type of block l_i
      unsigned l_ii = N_fluid_doftypes + l_i;

      // Extract the block
//      this->get_block_vector(Doftype_list_vpl[l_ii],r,temp_vec);
      this->get_block_vector(l_ii,r,temp_vec);
      W_preconditioner_pts[l_i]->preconditioner_solve(temp_vec,
                                                      another_temp_vec);

//      this->return_block_vector(Doftype_list_vpl[l_ii],another_temp_vec,z);
      this->return_block_vector(l_ii,another_temp_vec,z);
      temp_vec.clear();
      another_temp_vec.clear();
    }

    // At this point, all vectors are cleared.

    std::cout << "Using_superlu_ns_preconditioner: " << Using_superlu_ns_preconditioner << std::endl; 
    //pause("done"); 
    
    if(Using_superlu_ns_preconditioner)
    {
      // Concatenate the fluid block vectors
      double t_get_merge_fluid_rhs_start = TimingHelpers::timer();

      bool distributed = this->master_distribution_pt()->distributed();
      
      LinearAlgebraDistribution* new_distribution_pt
        = new LinearAlgebraDistribution(problem_pt()->communicator_pt(),
            Fluid_block_size,distributed);

      temp_vec.build(new_distribution_pt,0.0);
      
      // v_nrow_i, for indexing the new merged vector.
      unsigned long v_nrow_i = 0;
      
      // Loop through the fluid rhs block vectors
      for(unsigned i = 0; i < N_fluid_doftypes; i++)
      {
//        this->get_block_vector(Doftype_list_vpl[i],r,another_temp_vec);
        this->get_block_vector(i,r,another_temp_vec);
        unsigned long current_block_nrow = another_temp_vec.nrow();

        // Loop through the entries in this block vector
        for(unsigned long current_block_i = 0;
            current_block_i < current_block_nrow;
            current_block_i++)
        {
          temp_vec[v_nrow_i] = another_temp_vec[current_block_i];
          v_nrow_i++;
        } // for
        another_temp_vec.clear();
      } // for
      double t_get_merge_fluid_rhs_finish = TimingHelpers::timer();
      if(Doc_time && (curr_its == 0))
      {
        double t_get_merge_fluid_rhs_time = t_get_merge_fluid_rhs_finish
          - t_get_merge_fluid_rhs_start;
        std::cout << "t_get_merge_fluid_rhs_time: "
          << t_get_merge_fluid_rhs_time << endl;
      }

      // temp_vec contains the fluid rhs.
      Navier_stokes_preconditioner_pt->preconditioner_solve(temp_vec,another_temp_vec);
      temp_vec.clear();

      // We now have to put the block vectors in another_temp_vec back!
      double t_put_back_rhs_start = TimingHelpers::timer();
      unsigned long merged_vec_row_i = 0;
      // loop through the fluid block vectors
      // to extract entries from the merged vector.
      for(unsigned i = 0; i < N_fluid_doftypes; i++)
      {
//        this->get_block_vector(Doftype_list_vpl[i],r,temp_vec);
        this->get_block_vector(i,r,temp_vec);
        unsigned long current_block_nrow = temp_vec.nrow();

        // loop through the entries of this block vector
        for(unsigned long current_block_i = 0;
            current_block_i < current_block_nrow;
            current_block_i++)
        {
          temp_vec[current_block_i] = another_temp_vec[merged_vec_row_i];
          merged_vec_row_i++;
        }
//        this->return_block_vector(Doftype_list_vpl[i],temp_vec,z);
        this->return_block_vector(i,temp_vec,z);
        temp_vec.clear();
      }//for

      double t_put_back_rhs_finish = TimingHelpers::timer();
      if(Doc_time && (curr_its==0))
      {
        double t_put_back_rhs_time = t_put_back_rhs_finish
          - t_put_back_rhs_start;
        std::cout << "t_put_back_rhs_time: "
          << t_put_back_rhs_time << std::endl;
      }
    }
    else
    {
      //std::cout << "lagrange_enfor.. not using SuperLU_ns_prec " << std::endl; 
      
      Navier_stokes_preconditioner_pt->preconditioner_solve(r,z);
    }
  } // end of preconditioner_solve

 void set_meshes(Vector<Mesh*> meshes_pt)
 {
   Meshes_pts = meshes_pt;
   unsigned nmeshes = Meshes_pts.size();
   this->set_nmesh(nmeshes);
 }


  /// \short Access function to the Scaling sigma of the preconditioner
  double& scaling_sigma()
  {
    Use_default_norm_of_f_scaling = false;
    return Scaling_sigma;
  }
/// \short Function to get the scaling Sigma of the preconditioner
  double scaling_sigma() const
  {
    return Scaling_sigma;
  }

   /// \short Helper function to assemble the diagonal of the pressure
   /// and velocity mass matrices from the elemental contributions defined in
   /// NavierStokesEquations<DIM>.
   /// If do_both=true, both are computed, otherwise only the velocity
   /// mass matrix (the LSC version of the preconditioner only needs
   /// that one)
   void assemble_inv_press_and_veloc_mass_matrix_diagonal(
    CRDoubleMatrix*& inv_p_mass_pt,
    CRDoubleMatrix*& inv_v_mass_pt,
    const bool& do_both,
    const unsigned& procnumber,
    Problem* problem_pt);


  void use_default_norm_of_f_scaling()
  {
    Use_default_norm_of_f_scaling = true;
  }

   /// Function to set a new momentum matrix preconditioner (inexact solver)
   void set_navier_stokes_lsc_preconditioner(Preconditioner* new_ns_preconditioner_pt)
   {
    // If the default preconditioner has been used
    // clean it up now...
    if (Using_superlu_ns_preconditioner)
     {
      delete Navier_stokes_preconditioner_pt;
     }
    Navier_stokes_preconditioner_pt = new_ns_preconditioner_pt;
    Using_superlu_ns_preconditioner = false;
   }

   ///\short Function to (re-)set momentum matrix preconditioner (inexact
   /// solver) to SuperLU
   void set_navier_stokes_superlu_preconditioner()
   {
    if (!Using_superlu_ns_preconditioner)
     {
      delete Navier_stokes_preconditioner_pt;
      Navier_stokes_preconditioner_pt = new SuperLUPreconditioner;
      Using_superlu_ns_preconditioner = true;
     }
   }

   /// Function to set a new momentum matrix preconditioner (inexact solver)
   void set_w_preconditioner(Preconditioner* new_w_preconditioner_pt)
   {
    // If the default preconditioner has been used
    // clean it up now...
    if (Using_superlu_w_preconditioner)
     {
      delete W_preconditioner_pt;
     }
    W_preconditioner_pt = new_w_preconditioner_pt;
    Using_superlu_w_preconditioner = false;
   }

   ///\short Function to (re-)set momentum matrix preconditioner (inexact
   /// solver) to SuperLU
   void set_w_superlu_preconditioner()
   {
    if (!Using_superlu_w_preconditioner)
     {
      delete W_preconditioner_pt;
      Using_superlu_w_preconditioner = true;
     }
   }



///raydo comment
  void set_doc_info(DocInfo* doc_info)
  {
    Doc_info_pt = doc_info;
  }
  /// \short Clears the memory.
  void clean_up_memory();

   private:

  // For book keeping
  string Label;

  bool Doc_time;

  bool Doc_prec;

  bool Mapping_info_calculated;

  /// \short the Scaling_sigma variable of this preconditioner
  double Scaling_sigma;

  Vector<Mesh*> Meshes_pts;

  Vector<unsigned> N_doftype_in_mesh;

  ////////// NEW STUFF
  bool Use_default_norm_of_f_scaling;


  // Pointer to the 'preconditioner' for the W matrix
  // This will only be used if the user provides a preconditioner. Otherwise
  // we will use superLU preconditioners and solve each block using
  // W_preconditioner_pts
  Preconditioner* W_preconditioner_pt;

  // Pointer to the 'preconditioner' for the Navier-Stokes block
  Preconditioner* Navier_stokes_preconditioner_pt;
  // Same W solvers are used in both exact and LSC.
  // Pointer to the 'preconditoner' for the W matrix
  Vector<Preconditioner*> W_preconditioner_pts;

  // flag to indicate whether the default NS preconditioner is used
  bool Using_superlu_ns_preconditioner;

  // flag to indicate whether the default w preconditioner is used
  bool Using_superlu_w_preconditioner;

  // Bool to use diagonal or block diagonal W block.
  bool Use_diagonal_w_block;

  bool Preconditioner_has_been_setup;

  bool F_preconditioner_is_block_preconditioner;

  // the re-arraned doftypes: velocity, pressure, lagrange.
  Vector<unsigned> Doftype_list_vpl;
  // the re-arraned doftypes: bulk, constrained, pressure, lagrange.
  Vector<unsigned> Doftype_list_bcpl;


  // These are assigned in the setup but used in
  // preconditioner_solve() to re-arrange blocks.
  Vector<unsigned long> Doftype_block_size;
  unsigned long Fluid_block_size;
  unsigned long Pressure_block_size;
  unsigned long Velocity_block_size;

  //
  unsigned N_doftypes;
  unsigned N_lagrange_doftypes;
  unsigned N_fluid_doftypes;
  unsigned N_velocity_doftypes;

  DocInfo* Doc_info_pt;

 }; // end of LagrangeEnforcedflowPreconditioner class




/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

 //========================================================================
 /// add the scaled identity matrix to the specified block
 //========================================================================
  void LagrangeEnforcedflowPreconditioner::add_matrices(CRDoubleMatrix *&block_pt1,
                                                   CRDoubleMatrix *&block_pt2)
  {
    double* values1 = block_pt1->value();
    int* column_index1 = block_pt1->column_index();
    int* row_start1 = block_pt1->row_start();
    unsigned nrow_local1 = block_pt1->nrow_local();
    //unsigned first_row1 = block_pt1->first_row();
    unsigned nrow_global1 = block_pt1->nrow();

    double* values2 = block_pt2->value();
    int* column_index2 = block_pt2->column_index();
    int* row_start2 = block_pt2->row_start();
    //unsigned nrow_local2 = block_pt2->nrow_local();
    //unsigned first_row2 = block_pt2->first_row();

    // nrow_local should be the same.
    Vector< set<int> > column_set(nrow_local1);
    Vector<int> new_row_start(nrow_local1+1, 0);
    unsigned total_entries = 0;

    // Check which columns appear twice.
    pair<set<int>::iterator,bool> ret;

    for(unsigned i = 0; i < nrow_local1; i++)
    {
      // Union of both column indices
      for (int j = row_start1[i]; j < row_start1[i+1]; j++)
      {
        column_set[i].insert(column_index1[j]);
      }

      for (int j = row_start2[i]; j < row_start2[i+1]; j++)
      {
        ret = column_set[i].insert(column_index2[j]);
      }

      total_entries += column_set[i].size();
      new_row_start[i+1] = total_entries;
    }

    //Vector<double> ray_values33(9);
    //Vector<int> ray_column_indices33(9);
    //Vector<int> ray_row_start33(6);

  //cout << "Total entries: " << total_entries << endl;
  Vector<int> new_column_index(total_entries, 0);
  Vector<double> new_values(total_entries, 0);

  unsigned nci = 0;
  for(unsigned i = 0; i < nrow_local1; i++)
  {
    for(set<int>::const_iterator p = column_set[i].begin();
        p != column_set[i].end(); p++)
    {
      new_column_index[nci] =  *p;
      nci++;
      //cout << *p << " ";
    }
    //cout << endl;
  }



  // Now we add all the entries.

    for (unsigned i = 0; i < nrow_local1; i++)
      {
        // Adding the first matrix to the new matrix
        // Loop through the entries on ith row of matrix 1
        for (int j = row_start1[i]; j < row_start1[i+1]; j++)
        {
          bool found = false;
          // loop through the entries on the ith row of result matrix
          for (int jj = new_row_start[i]; jj  < new_row_start[i+1] && !found; jj++)
          {
            if(column_index1[j] == new_column_index[jj])
            {
              new_values[jj] += values1[j];
              found =true;
            }
          }
        }

        // Loop through the entries on ith row of matrix 2
        for (int j = row_start2[i]; j < row_start2[i+1]; j++)
        {
          bool found = false;
          // loop through the entries on the ith row of result matrix
          for (int jj = new_row_start[i]; jj  < new_row_start[i+1] && !found; jj++)
          {
            if(column_index2[j] == new_column_index[jj])
            {
              new_values[jj] += values2[j];
              found =true;
            }
          }
        }
      }

  // FIX THIS! This currently only works with square matrices
  block_pt2->build(nrow_global1,new_values,new_column_index,new_row_start);

  /// ENDS HERE
  /*
  cout << "new_column_index = " << endl;
  for(int i = 0; i < total_entries; i++)
  {
    cout << new_column_index[i] << " ";
  }
  cout << endl;

  cout << "new_row_start = ";
  for(int i = 0; i < nrow_local1 + 1; i++)
  {
    cout << new_row_start[i] << " ";
  }
  cout << endl;
  */
  } // add_matrices


  void LagrangeEnforcedflowPreconditioner::get_inf_norm(DenseMatrix<CRDoubleMatrix* >
                                                     &matrix_pt,
                                                   double &max_row_value)
  {
    unsigned long matrix_nrow = matrix_pt.nrow();
    unsigned long matrix_ncol = matrix_pt.ncol();

    max_row_value = 0.0;
    //unsigned test_i = 0;
    // Loop through the block rows.
    for(unsigned row_block = 0; row_block < matrix_nrow; row_block++)
    {
      // Get the number of rows in this row_block from the first block.
      unsigned long block_nrow_local = matrix_pt(row_block,0)->nrow_local();

      // Loop through the number of local rows
      for(unsigned i = 0; i < block_nrow_local; i++)
      {
        double current_row_total = 0.0;
        // Loop through the column blocks on this row:
        for(unsigned column_block = 0; column_block < matrix_ncol; column_block++)
        {
          CRDoubleMatrix* current_block_pt = matrix_pt(row_block,column_block);
          double* current_block_values = current_block_pt->value();
          //int* current_block_column_indicies = current_block_pt->column_index();
          int* current_block_row_start = current_block_pt->row_start();

          for(int j = current_block_row_start[i];
              j < current_block_row_start[i+1]; j++)
          {
            current_row_total += fabs(current_block_values[j]);
          } // loop through the
        } // loop through the columns

        max_row_value = max(max_row_value, current_row_total);
      } // loop through the local rows
    } // loop through the block rows
  } // void LagrangeEnforcedflowPreconditioner::get_inf_norm


 //========================================================================
 /// add the scaled identity matrix to the specified block
 //========================================================================
  void LagrangeEnforcedflowPreconditioner::get_diag(CRDoubleMatrix *&block_pt,
                                                       Vector<double>& diag)
  {
    // Note that diag_sqrd is nrow_local long.
    double* values = block_pt->value();
    int* column_index = block_pt->column_index();
    int* row_start = block_pt->row_start();
    unsigned nrow_local = block_pt->nrow_local();
    unsigned first_row = block_pt->first_row();

      for (unsigned i = 0; i < nrow_local; i++)
      {
        bool found = false;
        for (int j = row_start[i]; j < row_start[i+1] && !found; j++)
        {
          if (column_index[j] == (int)(i + first_row))
          {
            diag[i] = values[j];
            found = true;
          }
        }
        if(!found)
        {
          diag[i] = 0.0;
        }
      }
  } // end_of_get_diag(CRDoubleMatrix *&block_pt,Vector<double>& diag)

 //========================================================================
 /// add the scaled identity matrix to the specified block
 //========================================================================
  void LagrangeEnforcedflowPreconditioner::add_scaling_to_diag(double &Scaling,
                                                 CRDoubleMatrix *&block_pt)
  {
    double* values = block_pt->value();
    int* column_index = block_pt->column_index();
    int* row_start = block_pt->row_start();
    unsigned nrow_local = block_pt->nrow_local();
    unsigned first_row = block_pt->first_row();

    // We check if there are any zero entries on the diagonal of
    // the block.
    long unsigned nzero_diag = 0;
    Vector<unsigned> diag_pres(nrow_local, 0);
    for (unsigned i = 0; i < nrow_local; i++)
    {
      bool found = false;
      for (int j = row_start[i];
           j < row_start[i+1] && !found; j++)
      {
        if (column_index[j] == (int)(i + first_row))
        {
          diag_pres[i] = 1;
          found = true;
        }
      }
      if(!found)
      {
        nzero_diag++;
      }
    }

    if(nzero_diag != 0)
    {
      long unsigned nnz = block_pt->nnz();
      Vector<double> new_values(nnz + nzero_diag);
      Vector<int> new_column_index(nnz + nzero_diag);
      Vector<int> new_row_start(nrow_local+1);
      long unsigned offset = 0;
      unsigned nrow_global = block_pt->nrow();
      new_row_start[0] = row_start[0];

      // Loop through each row
      for(unsigned i = 0; i < nrow_local; i++)
      {
        // Have we set the artificial zero yet?
        bool set_zero = false;

        if(diag_pres[i])
        {
          // The diagonal is present. We just copy over the
          // column index and value.
          for(int j = row_start[i]; j < row_start[i+1]; j++)
          {
            if (column_index[j] == (int)(i + first_row))
            {
              new_column_index[j + offset] = column_index[j];
              new_values[j + offset] = values[j] + Scaling; // added scaling.
            }
            else
            {
              new_column_index[j + offset] = column_index[j];
              new_values[j + offset] = values[j];
            }
          }
        }
        else
        {
          // Diagonal is zero. There are 3 cases:
          // (1) Zero row - there are no non-zero entries on this row.
          // (2) Right entry - there are non-zero entries to the right
          //                   of the diagonal
          // (3) Left entry only - there are entries to the left
          //                       of the diagonal ONLY.

          // Case (1):
          if(row_start[i] == row_start[i+1])
          {
            // Zero row, set the artificial zero.
            new_column_index[row_start[i] + offset] = i + first_row;
            new_values[row_start[i] + offset] = Scaling; // added scaling
            offset++;
            set_zero = true;
          }
          else
          {
            // Case (2) and (3): There are some values on this row.
            // We loop through all of these values.
            for(int j = row_start[i]; j < row_start[i+1]; j++)
            {
              if(column_index[j] < (int)(i + first_row))
              {
                // First we copy all the values to the left of the diagonal.
                new_column_index[j + offset] = column_index[j];
                new_values[j + offset] = values[j];
              }
              else
              {
                // Now we are at either the diagonal or
                // to the right of the diagonal.

                if(!set_zero)
                {
                  // We have reached the diagonal.
                  new_column_index[j + offset] = i + first_row;
                  new_values[j + offset] = Scaling; // added scaling
                  offset++;
                  set_zero = true;
                }

                // Values to the right of the diagonal.
                new_column_index[j + offset] = column_index[j];
                new_values[j + offset] = values[j];
              }
            }
            // Case (3): If there are values to the left of the diagonal only,
            // we never reach the diagonal. We set the diagonal in this case.
            if(!set_zero)
            {
              new_column_index[row_start[i+1] + offset] = i + first_row;
              new_values[row_start[i+1] + offset] = Scaling; // added scaling
              offset++;
              set_zero = true;
            }

          }
        }
        new_row_start[i+1] = row_start[i+1]+offset;
      }
      // This assumes that this is a square matrix
      block_pt->build(nrow_global,new_values,new_column_index,new_row_start);
    }
    else
    {
      for (unsigned i = 0; i < nrow_local; i++)
      {
        bool found = false;
        for (int j = row_start[i]; j < row_start[i+1] && !found; j++)
        {
          if (column_index[j] == (int)(i + first_row))
          {
            values[j] += Scaling;
            found = true;
          }
        }
      }
    }
  }// end_of_add_scaling_on_diag

 //========================================================================
 /// Setup method for the LagrangeEnforcedflowPreconditioner.
 //========================================================================
 void LagrangeEnforcedflowPreconditioner::setup(Problem* problem_pt,
                                           DoubleMatrixBase* matrix_pt)
 {

  // For debugging
  //bool doc_block_matrices = false;
  bool Doc_time = false;

  // clean
  this->clean_up_memory();
  

  // To construct the required block structure for the preconditoner, we
  // require only the
  // (1) spatial dimension of the problem and
  // (2) the number of dof types in each of the meshes.
  //
  // We assume the first mesh is always the bulk mesh. Example:
  // The general structure for the dof types (in 3D) is
  //  0 1 2 3   4 5 6 7  8  ..x   x+0 x+1 x+2 x+3 x+4
  // [u v w p] [u v w l1 l2 ...] [u   v   w   l1  l2 ...] ...
  //
  // where then square brackets [] represents the dof types in each mesh.
  //
  // Consider the case of imposing parallel outflow (3 constrained velocity
  // dof types and 2 lagrange multiplier dof types) and tangential flow (3
  // constrained velocity dof types and 1 lagrange multiplier dof type)
  // along two different boundaries in 3D. The resulting natural block dof
  // type structure is:
  // [0 1 2 3] [4  5  6   7   8 ] [9  10 11 12 ]
  // [u v w p] [up vp wp Lp1 Lp2] [ut vt wt Lt1]
  //
  // Then the dimension = 3 and N_doftype_in_mesh = [4, 5, 4].
  //


  // Set the meshes. We assume that all sub meshes in the problem is used
  // for preconditioning. Thus order of the meshes is the same order in the
  // problem, which is the same order we call "add_sub_mesh(...)" for each
  // mesh in the problem constructor.

  // Store the number of meshes locally.
  unsigned nmesh = Meshes_pts.size();

#ifdef PARANOID
  // Paranoid check that meshes have been set.
  if(nmesh == 0)
  {
    std::ostringstream error_message;
    error_message << "There are no meshes set. Please call set_meshes(...)"
                  << std::endl;
    throw OomphLibError(error_message.str(),
        "LagrangeEnforcedflowPreconditioner::setup(...)",
        OOMPH_EXCEPTION_LOCATION);
  }

  // Check if all pointers has been set.
  for(unsigned mesh_i = 0; mesh_i < nmesh; mesh_i++)
  {
    if (Meshes_pts[mesh_i]==0)
    {
      std::ostringstream error_message;
      error_message << "The Meshes_pts[" << mesh_i << "] must be set." 
                    << std::endl;
      throw OomphLibError(error_message.str(),
                          "LagrangeEnforcedflowPreconditioner::setup(...)",
                          OOMPH_EXCEPTION_LOCATION);
    }
  }
#endif

  // We assume that the first mesh is the "bulk" mesh. To check this, the
  // elemental dimension must be the same as the nodal dimension.
  //
  // We store the elemental dimension i.e. the number of local coordinates
  // required to parametrise its geomentry.
  unsigned elemental_dimension = Meshes_pts[0]->finite_element_pt(0)->dim();

#ifdef PARANOID
  // The dimension of the nodes in the first element in the bulk mesh.
  unsigned nodal_dimension = Meshes_pts[0]->finite_element_pt(0)
                                         ->nodal_dimension();
  if (elemental_dimension != nodal_dimension) 
  {
    std::ostringstream error_message;
    error_message << "In the first mesh, the elemental dimension is "
                  << elemental_dimension << " with a nodal dimension of "
                  << nodal_dimension << ".\n"
                  << "The first mesh is not the bulk mesh.\n"
                  << "Please re-assign the meshes vector." << std::endl;

    throw OomphLibError(error_message.str(),
                        "LagrangeEnforcedflowPreconditioner::setup(...)",
                        OOMPH_EXCEPTION_LOCATION);
  }
#endif

  // set the mesh
  for(unsigned mesh_i = 0; mesh_i < nmesh; mesh_i++)
  {
    this->set_mesh(mesh_i,problem_pt,Meshes_pts[mesh_i]);
  }
  
  // Reset some variables:
  N_doftypes = 0;
  N_doftype_in_mesh.assign(nmesh,0);

  // Compute the variables we just reset!
  if (this->is_master_block_preconditioner())
  {
    // Loop through the meshes.
    for(unsigned mesh_i = 0; mesh_i < nmesh; mesh_i++)
    {
      unsigned mesh_ndoftype = this->ndof_types_in_mesh(mesh_i);
      N_doftypes += mesh_ndoftype;
      N_doftype_in_mesh[mesh_i] = mesh_ndoftype;
//      std::cout << "mesh_i = " << mesh_i
//                << ", mesh_ndoftype = " << mesh_ndoftype << std::endl;
    }
  }
  else
  {
    // RAYEDIT - I'm not sure what to do here.
    // I'll cross the bridge when I come to it.
    N_doftypes = this->ndof_types();
    N_fluid_doftypes = 5; // rayupdate update this! (int)(((double)2*n_dof_types)/3);
  }

  // Determine the number of velocity dof types
  // We assume that the velocities are constrained in all meshes.
  // i.e. in all meshes we have velocities that are constrained.
  N_velocity_doftypes = nmesh*elemental_dimension;
  N_fluid_doftypes = N_velocity_doftypes + 1;
  N_lagrange_doftypes = N_doftypes - N_fluid_doftypes;


  
// Testing: ///////////////////////////////////////////////////////////////////
// I should get:
//  nmesh = 3;
//  N_doftype_in_mesh.resize(nmesh,0);
//  N_doftype_in_mesh[0] = 4;
//  N_doftype_in_mesh[1] = 5;
//  N_doftype_in_mesh[2] = 4;
//  N_doftypes = 13;
//  elemental_dimension = 3;
//  N_velocity_doftypes = elemental_dimension*nmesh;
/////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// New code, new blocking scheme.
  // Re-order the dof_types.
  // The natural ordering of the dof types are ordered by their meshes.
  // We want all the bulk velocities together, then the constrained velocities,
  // then the pressure, and finally the Lagrange multiplier block.
  // Consider the same example above:
  // [0 1 2 3] [4  5  6   7   8 ] [9  10 11 12]
  // [u v w p] [up vp wp Lp1 Lp2] [ut vt wt Lt1]
  //
  // We want:
  //  0 1 2   4  5  6    9  10 11    3    7   8  12
  // [u v w | up vp wp | ut vt wt ] [p | Lp1 Lp2 Lt1]
  //
  // This is stored in Doftype_list_bcpl, this is passed to turn_into_subsi...
  { // encapsulating temp vectors.
    Vector<unsigned> temp_fluid_doftypes;
    Vector<unsigned> temp_lagrange_doftypes;
    
    unsigned increment = 0;
    for(unsigned mesh_i = 0; mesh_i < nmesh; mesh_i++)
    {
      for(unsigned dim_i = 0; dim_i < elemental_dimension; dim_i++)
      {
        temp_fluid_doftypes.push_back(increment);
        increment++;
      } // for elemental_dimension

      for(unsigned l_i = elemental_dimension; l_i < N_doftype_in_mesh[mesh_i];
          l_i++)
      {
        temp_lagrange_doftypes.push_back(increment);
        increment++;
      }
    } // for nmesh

    Doftype_list_bcpl.clear();
    Doftype_list_bcpl.reserve(temp_fluid_doftypes.size() + 
                              temp_lagrange_doftypes.size());
    Doftype_list_bcpl.insert(Doftype_list_bcpl.end(),
                             temp_fluid_doftypes.begin(),
                             temp_fluid_doftypes.end());
    Doftype_list_bcpl.insert(Doftype_list_bcpl.end(),
                             temp_lagrange_doftypes.begin(),
                             temp_lagrange_doftypes.end());
  } // end of encapculating


//  std::cout << "Doftype_list_bcpl:" << std::endl; 
//  for (unsigned i = 0; i < Doftype_list_bcpl.size(); i++) 
//  {
//    std::cout << Doftype_list_bcpl[i] << std::endl;
//  }
//  pause("Done the new doftype list"); 


// Testing: ///////////////////////////////////////////////////////////////////
// I should get:
//  nmesh = 3;
//  N_doftype_in_mesh.resize(nmesh,0);
//  N_doftype_in_mesh[0] = 4;
//  N_doftype_in_mesh[1] = 5;
//  N_doftype_in_mesh[2] = 4;
//  N_doftypes = 13;
//  elemental_dimension = 3;
//  N_velocity_doftypes = elemental_dimension*nmesh;
/////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// New code, new blocking scheme.
  // Re-order the dof_types.
  // The natural ordering of the dof types are ordered by their meshes.
  // We want to tell the blocks where they should be in the 
  // new blocking scheme.
  //
  // This corresponds with the Doftype_list_bcpl above. We want 
  // all the bulk velocities, the constrained velocities, pressure, and 
  // finally the Lagrange multiplier block.
  //
  // Consider the same example above:
  // [0 1 2 3] [4  5  6   7   8 ] [9  10 11 12]
  // [u v w p] [up vp wp Lp1 Lp2] [ut vt wt Lt1]
  //
  // We want:
  //  0 1 2 9 3  4  5  10  11  6  7  8  12
  // [u v w p up vp wp Lp1 Lp2 ut vt wt Lt1
  //
  // This is stored in Doftype_list_bcpl, this is passed to block_setup...

  Vector<unsigned> block_setup_bcpl(N_doftypes,0);
  {
    unsigned temp_index = 0;
    unsigned lagrange_entry = N_velocity_doftypes;
    for (unsigned mesh_i = 0; mesh_i < nmesh; mesh_i++)
    {
      for (unsigned dim_i = 0; dim_i < elemental_dimension; dim_i++) 
      {
        block_setup_bcpl[temp_index] = dim_i + mesh_i*elemental_dimension;
        temp_index++;
      }

      for (unsigned doftype_i = elemental_dimension; 
           doftype_i < N_doftype_in_mesh[mesh_i]; doftype_i++) 
      {
        block_setup_bcpl[temp_index] = lagrange_entry;
        lagrange_entry++;
        temp_index++;
      }
    }
  }

//  std::cout << "block_setup_bcpl:" << std::endl; 
//  for (unsigned i = 0; i < block_setup_bcpl.size(); i++) 
//  {
//    std::cout << block_setup_bcpl[i] << std::endl;
//  }
//  pause("Done the block_setup_bcpl"); 


this->block_setup(problem_pt,matrix_pt,block_setup_bcpl);
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////





// Testing: ///////////////////////////////////////////////////////////////////
// I should get:
// 0 4 8 12 1 5 9 13 2 6 10 14 15 3 7 11 16 17 18
//  nmesh = 4;
//  N_doftype_in_mesh.resize(nmesh,0);
//  N_doftype_in_mesh[0] = 4;
//  N_doftype_in_mesh[1] = 4;
//  N_doftype_in_mesh[2] = 5;
//  N_doftype_in_mesh[3] = 6;
//  N_doftypes = 19;
//  elemental_dimension = 3;
//  N_velocity_doftypes = elemental_dimension*nmesh;
///////////////////////////////////////////////////////////////////////////////
  
  // Re-order the dof_types.
  // The natural ordering of the dof types are ordered by their meshes.
  // We want to group all the velocities (together with their directions),
  // Then the pressure, finally the Lagrange multiplier block.
  // Consider the same example above:
  // [0 1 2 3] [4  5  6   7   8 ] [9  10 11 12]
  // [u v w p] [up vp wp Lp1 Lp2] [ut vt wt Lt1]
  //
  // We want:
  //  0 3 6 |9|   1  4  7  |10  11 |   2  5  8  |12 |
  // [u v w |p|] [up vp wp |Lp1 Lp2|] [ut vt wt |Lt1|]
  //    MESH1            MESH2            
  //
  // We have elemental_dimension and N_doftype_in_mesh[].
//  Vector<unsigned>block_setup_vpl(N_doftypes,0);
//
//  // Loop through the meshes
//  unsigned temp_index = 0;
//  unsigned lagrange_entry = N_velocity_doftypes;
//  for (unsigned mesh_i = 0; mesh_i < nmesh; mesh_i++) 
//  {
//    // Fill in the velocity doftypes of the current mesh.
//    // dim_i * nmesh gives constants per mesh, we increment this with mesh_i
//    // for each subsequent mesh.
//    for (unsigned dim_i = 0; dim_i < elemental_dimension; dim_i++) 
//    {
//      block_setup_vpl[temp_index] = dim_i * nmesh + mesh_i;
//      temp_index++;
//    }
//
//    // Now that all the velocity dof types of this mesh is filled,
//    // we fill in the pressure or lagrange multiplier types.
//    for (unsigned doftype_i = elemental_dimension;
//         doftype_i < N_doftype_in_mesh[mesh_i]; doftype_i++)
//    {
//      block_setup_vpl[temp_index] = lagrange_entry;
//      temp_index++;
//      lagrange_entry++;
//    }
//  }
//  
  // print it:
//  std::cout << "block_setup_vpl: " << std::endl;
//  for (unsigned i = 0; i < N_doftypes; i++) 
//  {
//    std::cout << block_setup_vpl[i] << " ";
//  }
//  std::cout << std::endl; 
//  pause("done new vpl"); 

  // Call block setup for this preconditioner
 // this->block_setup(problem_pt,matrix_pt,block_setup_vpl);

  // Recast Jacobian matrix to CRDoubleMatrix
#ifdef PARANOID
  CRDoubleMatrix* cr_matrix_pt = dynamic_cast<CRDoubleMatrix*>(matrix_pt);
  if (cr_matrix_pt==0)
  {
    std::ostringstream error_message;
    error_message << "PrallelOutflowPreconditioner only works with"
                  << " CRDoubleMatrix matrices" << std::endl;
    throw OomphLibError(error_message.str(),
                        "LagrangeEnforcedflowPreconditioner::setup(...)",
                        OOMPH_EXCEPTION_LOCATION);
  }
#else
  CRDoubleMatrix* cr_matrix_pt = static_cast<CRDoubleMatrix*>(matrix_pt);
#endif







//  for (unsigned block_i = 0; block_i < N_doftypes; block_i++) 
//  {
//    CRDoubleMatrix* temp_matrix_pt = 0;
//    this->get_block(0,block_i,cr_matrix_pt,temp_matrix_pt);
//    unsigned temp_matrix_ncol = temp_matrix_pt->ncol();
//    std::cout << "block: " << block_i 
//              << ", ncol: " << temp_matrix_ncol << std::endl; 
//    
//  }
//  pause("done"); 


  // Re-order the dof_types.
  // The natural ordering of the dof types are ordered by their meshes.
  // We want to group all the velocities (together with their directions),
  // Then the pressure, finally the Lagrange multiplier block.
  // Consider the same example above:
  // [0 1 2 3] [4  5  6   7   8 ] [9  10 11 12]
  // [u v w p] [up vp wp Lp1 Lp2] [ut vt wt Lt1]
  //
  // We want:
  //  0 4  9  1 5  10  2 6  11   3    7   8  12
  // [u up ut v vp vt  w wp wt ] [p] [Lp1 Lp2 Lt1]
  //
  // This is stored in Doftype_list_vpl,
//std::cout << "N_doftypes: " << N_doftypes << std::endl; 
//pause("test"); 

// RAYCOMMENT
//  Doftype_list_vpl.assign(N_doftypes,0);
//  unsigned incre_i = 0;
//  // Loop through the dimensions and fill in the velocity doftypes
//  for(unsigned dim_i = 0; dim_i < elemental_dimension; dim_i++)
//  {
//    unsigned lagrange_offset = 0;
//
//    // Loop through the meshes
//    for(unsigned mesh_i = 0; mesh_i < nmesh; mesh_i++)
//    {
//      // dim_i offsets for the velocities, u=0, v=1 or w=2.
//      // lagrange_offset is used to offset the additional doftypes which are
//      // not velocity doftypes.
//      //
//      // Note that the lagrange_offset is the number of non-velocity dof types
//      // in the previous mesh. So for the first mesh, for the example above,
//      // we have: l_offset =
//      // (dim_i = 0) 0 -> 1 -> 3
//      // (dim_i = 1) 0 -> 1 -> 3
//      // (dim_i = 2) 0 -> 1 -> 3
//      //
//      // This helps offsets the velocity which would otherwise be:
//      // [0 3 6 1 4 7 2 5 8]
//      Doftype_list_vpl[incre_i] = mesh_i*elemental_dimension + dim_i + lagrange_offset;
//      lagrange_offset += N_doftype_in_mesh[mesh_i] - elemental_dimension;
//      incre_i++;
//    } // for mesh_i
//  } // dim_i
//
//  // Now fill in all the entries of the additional doftypes.
//  // Loop through the meshes
//  unsigned lagrange_offset = 0;
//  for(unsigned mesh_i = 0; mesh_i < nmesh; mesh_i++)
//  {
//    // This corresponds to getting the "one past" the w velocity, dim_i = elemental_dimension.
//    // See the previous loop for details.
//    unsigned doftype_begin = mesh_i*elemental_dimension + elemental_dimension + lagrange_offset;
//    lagrange_offset = lagrange_offset + N_doftype_in_mesh[mesh_i] - elemental_dimension;
//
//    // Move to the end of the additional doftypes. Note that this corresponds
//    // to the u velocity (dim_i = 0, see the previous loop).
//    unsigned doftype_end = (mesh_i+1)*elemental_dimension + lagrange_offset;
//
//    // Loop through the additional doftypes / pressure.
//    for(unsigned doftype_i = doftype_begin; doftype_i < doftype_end; doftype_i++)
//    {
//      Doftype_list_vpl[incre_i] = doftype_i;
//      incre_i++;
//    } // for doftype_i
//  } // for mesh_i

  //* //RRR_DUMP
//  cout << "Doftype_list_vpl[i]:"<< endl;
//  for(unsigned i = 0; i < N_doftypes; i++)
//  {
//    cout << Doftype_list_vpl[i] << endl;
//  }
  // */
  // Store the size of get type of block.
  // This will be used in the preconditioner_solve() function.
  // (per Newton iteration, per Newton Step) when re-arranging
  // the block vectors.
  Doftype_block_size.assign(N_doftypes,0);
  for(unsigned i = 0; i < N_doftypes; i++)
  {
    //Doftype_block_size[i] = block_distribution_pt(Doftype_list_vpl[i])->nrow_local();
    Doftype_block_size[i] = block_distribution_pt(i)->nrow_local();
  } // for N_doftypes

//  for (unsigned doftype_i = 0; doftype_i < N_doftypes; doftype_i++) 
//  {
//    std::cout << "nrow_local: " << Doftype_block_size[doftype_i] << std::endl; 
//  }
//pause("done"); 

  Fluid_block_size = 0;
  Pressure_block_size = 0;
  Velocity_block_size = 0;
  for(unsigned i = 0; i < N_velocity_doftypes; i++)
  {
    Velocity_block_size += Doftype_block_size[i];
  }

  Pressure_block_size = Doftype_block_size[N_velocity_doftypes];

  Fluid_block_size = Velocity_block_size + Pressure_block_size;
  
//  std::cout << "Velocity_block_size: " << Velocity_block_size << std::endl; 
//  std::cout << "Pressure_block_size: " << Pressure_block_size << std::endl; 
//  std::cout << "Fluid_block_size: " << Fluid_block_size << std::endl; 
  
  
    
  // Setting up the submatrix dimension file.
  if(Doc_prec)
  {
    // This is for bebugging purposes.
    string currentsetting = Doc_info_pt->label() + "NS"
                            + to_string(Doc_info_pt->current_nnewton_step());


    // Output the number of blocks.
    std::ofstream precinfo_ofstream;
    string precinfo_string = "precinfo_" + currentsetting;
    precinfo_ofstream.open(precinfo_string.c_str());
    // The dimension
    precinfo_ofstream << elemental_dimension << " ";
    // The number of blocks
    unsigned nblock_types = this->nblock_types();

    for (unsigned mesh_i = 0; mesh_i < nmesh; mesh_i++)
    {
      precinfo_ofstream << N_doftype_in_mesh[mesh_i] << " ";
    }
    precinfo_ofstream.close();

    // Loop through all the blocks and output them.
    for(unsigned Mi=0; Mi<nblock_types; Mi++)
    {
      for(unsigned Mj=0; Mj<nblock_types; Mj++)
      {
        CRDoubleMatrix* sub_matrix_pt = 0;
        this->get_block(Mi,Mj,cr_matrix_pt,sub_matrix_pt);
        std::stringstream blockname;
        blockname << "j_"<< currentsetting<< "_"
          << setw(2) << setfill('0') << Mi
          << setw(2) << setfill('0') << Mj;
        sub_matrix_pt->sparse_indexed_output(blockname.str());
        delete sub_matrix_pt;
        sub_matrix_pt = 0;
      }//for
    }//for

    // Now get the mass matrices for LSC solve

    // Extract all of the inv_v_mass.
    bool do_both=false;
    CRDoubleMatrix* inv_v_mass_pt = 0;
    CRDoubleMatrix* inv_p_mass_pt = 0;

    for(unsigned dof_type_i = 0;
        dof_type_i < N_velocity_doftypes; dof_type_i++)
    {
      unsigned required_block = dof_type_i; //Doftype_list_vpl[dof_type_i];
      assemble_inv_press_and_veloc_mass_matrix_diagonal
        (inv_p_mass_pt, inv_v_mass_pt,
         do_both, required_block,problem_pt);
      //if(Doc_info->is_doc_prec_data_enabled())
      {
        std::stringstream blockname;
        blockname << "vmm_"<< currentsetting<< "_"
          << setw(2) << setfill('0') << required_block
          << setw(2) << setfill('0') << required_block;
        inv_v_mass_pt->sparse_indexed_output(blockname.str());
        delete inv_v_mass_pt;
      }
    }
  }// if Doc_prec


  ///////////////////////////////////////////////////////////////////////////
/*
  cout << "Velocity_block_size" << Velocity_block_size << endl;
  cout << "Pressure_block_size" << Pressure_block_size << endl;
  cout << "Fluid_block_size" << Fluid_block_size << endl;
  pause("done done");
// */
  ////////////////////////////////////////////////////////////////////////////////
  // Need to create the norms, used for Sigma, if required

  if(Use_default_norm_of_f_scaling)
  {
  // Create the scaling, norm of the momentum block.
  // Creating A, Ax and Ay to see the infinity norm, we re-arrange the matrix:
  // A = 0-4, Ax = 0-3, Ay = 1-4
  //    0    3     1    4     2    5
  //  0 Axx  Axxo  Axy  Axyo  Bxt  0
  //  3 Axox Axoxo Axoy Axoyo Bxot Mx
  //  1 Ayx  Ayxo  Ayy  Ayyo  Byt  0
  //  4 Ayox Ayoxo Ayoy Ayoyo Byot My
  //  2 Bx   Bxo   By   Byo   0    0
  //  5 0    Mx    0    My    0    0

  double ax_norm = 0.0;
  /*
  double a_norm = 0.0;
  DenseMatrix<CRDoubleMatrix* > a_pts(N_velocity_doftypes,
                                      N_velocity_doftypes,0);
  for(unsigned row_i = 0; row_i < N_velocity_doftypes; row_i++)
  {
    for(unsigned col_i = 0; col_i < N_velocity_doftypes; col_i++)
    {
      this->get_block(Doftype_list_vpl[row_i], Doftype_list_vpl[col_i],
                      cr_matrix_pt,a_pts(row_i,col_i));
    }
  }
  get_inf_norm(a_pts,a_norm);
  // */

  double t_norm_ax_start = TimingHelpers::timer();
  // Get the momentum block corresponding to the u (velocity in the
  // x direction) block.
  DenseMatrix<CRDoubleMatrix* > ax_pts(nmesh,nmesh,0);
  // Recall the blocking scheme:
  // 0 1 2 3  4  5  6  7  8
  // u v w u1 v1 w1 u2 v2 w2 ...
  // So we loop through the meshes and then get the first entry...
  for(unsigned row_i = 0; row_i < nmesh; row_i++)
  {
    for(unsigned col_i = 0; col_i < nmesh; col_i++)
    {
//      this->get_block(Doftype_list_vpl[row_i], Doftype_list_vpl[col_i],
//                      cr_matrix_pt,ax_pts(row_i,col_i));
      unsigned required_row_i = row_i * elemental_dimension;
      unsigned required_col_i = col_i * elemental_dimension;
      this->get_block(required_row_i, required_col_i,
                      cr_matrix_pt,ax_pts(row_i,col_i));
    } // for
  } //  for


  // Get the norm
  get_inf_norm(ax_pts,ax_norm);
  double t_norm_ax_finish = TimingHelpers::timer();

  // Clear memory
  for(unsigned row_i = 0; row_i < nmesh; row_i++)
  {
    for(unsigned col_i = 0; col_i < nmesh; col_i++)
    {
      delete ax_pts(row_i,col_i);
    }
  }


  if(Doc_time)
  {
    double t_norm_ax_time = t_norm_ax_finish - t_norm_ax_start;
    cout << "t_norm_ax_time: " << t_norm_ax_time << std::endl;
  }

  // Set Scaling_sigma
  Scaling_sigma =  -ax_norm;
  } // if(Use_default_f_scaling)

#ifdef PARANOID
  if(Scaling_sigma == 0.0)
  {
    std::ostringstream warning_stream;
    warning_stream << "WARNING: " << std::endl
                   << "The scaling (Scaling_sigma) is " << Scaling_sigma << std::endl
                   << "Division by Scaling_sigma = 0 will implode the world."
                   << std::endl;
    OomphLibWarning(warning_stream.str(),
                    "LagrangeEnforcedflowPreconditioner::setup(...)",
                    OOMPH_EXCEPTION_LOCATION);
  }
  if(Scaling_sigma > 0.0)
  {
    std::ostringstream warning_stream;
    warning_stream << "WARNING: " << std::endl
                   << "The scaling (Scaling_sigma) is " << Scaling_sigma << std::endl
                   << "Performance may be degraded."
                   << std::endl;
    OomphLibWarning(warning_stream.str(),
                    "LagrangeEnforcedflowPreconditioner::setup(...)",
                    OOMPH_EXCEPTION_LOCATION);
  }
#endif


  std::streamsize cout_precision = cout.precision();
  cout << "RAYSIGMA: " << std::setprecision(15) << Scaling_sigma
                       << std::setprecision(cout_precision)
                       << endl;

  ///////////////////////////////////////////////////////////////////////////
  // We extract the velocity blocks then create the augmented fluid matrix.//
  ///////////////////////////////////////////////////////////////////////////

  // Extract the velocity block.
  DenseMatrix<CRDoubleMatrix*> v_aug_pt(N_velocity_doftypes,
                                        N_velocity_doftypes,0);
  for(unsigned row_i = 0; row_i < N_velocity_doftypes; row_i++)
  {
    for(unsigned col_i = 0; col_i < N_velocity_doftypes; col_i++)
    {
//      this->get_block(Doftype_list_vpl[row_i], Doftype_list_vpl[col_i],
//                      cr_matrix_pt,v_aug_pt(row_i,col_i));
      this->get_block(row_i,col_i,cr_matrix_pt,v_aug_pt(row_i,col_i));
    } // for
  } // for

  // Loop through the Lagrange multipliers and do three things:
  // For each Lagrange block:
  //   Create an empty w_i, this will be constructed incrementally from the
  //   mass matrices (in the columns).
  //
  //   For each block column
  //     1) Store the location of mass matrix.
  //     2) Store the mass matrix.
  //     3) Create the partial w_i += diag(m)^2
  //
  //   1) Store the w_i for this lagrange multiplier.
  //   Loop through the mass matrix location to determine the aug. row.
  //     Loop through the mm location to determine the aug. col.
  //       1) Create inv_wi from the w_i already created.
  //       1) Create augmentation m * inv(w_i) * m
  //       2) Add the augmentation as determined by aug. row and aug. col.

  // Storage for the W block.
  DenseMatrix<CRDoubleMatrix* > w_pts(1,N_lagrange_doftypes,0);
  // Note that we do not need to store all the inverse w_i since they
  // are only used once per lagrage multiplier.
  for(unsigned l_i = 0; l_i < N_lagrange_doftypes; l_i++)
  {
    // Storage for the current lagrange block mass matrices.
    Vector<CRDoubleMatrix*> mm_pts;

    // Get the current lagrange doftype.
    unsigned l_doftype = N_fluid_doftypes + l_i;

    // Store the mass matrix locations for the current lagrange block.
    Vector<unsigned> mm_locations;
    
    // Store the number of mass matrices.
    unsigned n_mm = 0;

    // It is easier to create the diagonal matrix w_i after
    // I have extracted all the mass matrices for this Lagrange
    // block.

    // Go along the block columns for the current lagrange block.
    for(unsigned col_i = 0; col_i < N_velocity_doftypes; col_i++)
    {
      // Get the block matrix for this block column.
      CRDoubleMatrix* mm_temp_pt = 0;
//      this->get_block(Doftype_list_vpl[l_doftype], Doftype_list_vpl[col_i],
//                      cr_matrix_pt,mm_temp_pt);

      this->get_block(l_doftype, col_i, cr_matrix_pt,mm_temp_pt);

      if(mm_temp_pt->nnz() > 0)
      {
        mm_locations.push_back(col_i);
        mm_pts.push_back(mm_temp_pt);
        n_mm++;
      }
      else
      {
        delete mm_temp_pt;
      }

    } // loop through the columns of the lagrange row.
#ifdef PARANOID
  if (n_mm == 0) 
  {
    std::ostringstream warning_stream;
    warning_stream << "WARNING:\n"
                   << "There are no mass matrices on lagrange block " 
                   << l_i << ".\n"
                   << "Perhaps the problem setup is incorrect." << std::endl;
    OomphLibWarning(warning_stream.str(),
                    "LagrangeEnforcedflowPreconditioner::setup(...)",
                    OOMPH_EXCEPTION_LOCATION);
  }
#endif

    // the mass matrices for the current Lagrange block is
    // in mm_pts. Now create the w_i and put it in w_pts.
    
    // We first create the distribution for both w_i and inv_w_i block.
    bool distributed = this->master_distribution_pt()->distributed();

    unsigned long l_i_nrow_global = mm_pts[0]->nrow();
  
    LinearAlgebraDistribution* new_distribution_pt
      = new LinearAlgebraDistribution(problem_pt->communicator_pt(),
                                      l_i_nrow_global,distributed);

    // Create both the w_i and inv_w_i matrices.
    w_pts(0,l_i) = new CRDoubleMatrix(new_distribution_pt);
    CRDoubleMatrix* inv_w_pt = new CRDoubleMatrix(new_distribution_pt);

    // The w_i is either a
    // 1) diagonal or
    // 2) block diagonal
    // approximation of the actual W = LL^T block 
    // (LL^T has off-diagonal blocks).
    //
    // When w_i is inverted, we always take the diagonal approximation 
    // beforehand. In the case of (1), nothing needs to be done, 
    // but in (2) we need to extract the diagonal of the block-diagonal matrix.

    //unsigned long l_i_nrow_local = mm_pts[0]->nrow_local();
    
    
    
    //inv_w_pt->build(l_i_nrow_global,
     //               invw_i_diag_values,
      //              w_i_column_indices,
       //             w_i_row_start);
    //w_pts(0,l_i)->build(l_i_nrow_global,
    //                    w_i_diag_values,
    //                     w_i_column_indices,
    //                     w_i_row_start);

    if(Use_diagonal_w_block)
    {
      // Get the number of local rows for this lagrange block.
      // We shall use the block in the first column.
      unsigned long l_i_nrow_local = mm_pts[0]->nrow_local();
      
      // A Vector of Vectors containing the diagonals of
      // each mass matrix of this Lagrange mult. constraint.
      Vector<Vector<double> > m_diag(n_mm,Vector<double>(l_i_nrow_local,0.0));
      
      // Extract all the diagonals of the mass matrices for this
      // block lagrange row (l_i)
      for(unsigned m_i = 0; m_i < n_mm; m_i++)
      {
        get_diag(mm_pts[m_i],m_diag[m_i]);
      }

      // A vector to contain the results of mass matrices squared.
      Vector<double> w_i_diag_values(l_i_nrow_local,0);
      Vector<double> invw_i_diag_values(l_i_nrow_local,0);
      
      Vector<int> w_i_column_indices(l_i_nrow_local);
      Vector<int> w_i_row_start(l_i_nrow_local+1);
      
      // Component-wise, square and add all the diagonals.
      for(unsigned m_i = 0; m_i < n_mm; m_i++)
      {
        for(unsigned long row_i = 0; row_i < l_i_nrow_local; row_i++)
        {
          w_i_diag_values[row_i] += m_diag[m_i][row_i]*m_diag[m_i][row_i];
        }
      }

      // Divide by Scaling_sigma and create the inverse of w.
      for(unsigned long row_i = 0; row_i < l_i_nrow_local; row_i++)
      {
        w_i_diag_values[row_i] /= Scaling_sigma;
  
        // w_i is a diagonal matrix, so take the inverse to
        // invert the matrix.
        invw_i_diag_values[row_i] = 1/w_i_diag_values[row_i];
        w_i_column_indices[row_i] = row_i;
        w_i_row_start[row_i] = row_i;
      }
      
      w_i_row_start[l_i_nrow_local] = l_i_nrow_local;

      // Theses are square matrices
      w_pts(0,l_i)->build(l_i_nrow_global,
                          w_i_diag_values,
                           w_i_column_indices,
                           w_i_row_start);
      inv_w_pt->build(l_i_nrow_global,
                      invw_i_diag_values,
                      w_i_column_indices,
                      w_i_row_start);
    }
    else
    {
      // Square the first mass matrix. We assume that there is at least one.
      mm_pts[0]->multiply((*mm_pts[0]),(*w_pts(0,l_i)));
      
      // Square the other mass matrices and add the result to w_pts(0,l_i).
      for (unsigned mm_i = 1; mm_i < n_mm; mm_i++)
      {
        // Squaring process.
        CRDoubleMatrix* temp_mm_sqrd_pt = new CRDoubleMatrix;
        temp_mm_sqrd_pt->build(new_distribution_pt);
        mm_pts[mm_i]->multiply((*mm_pts[mm_i]),*temp_mm_sqrd_pt);
        
        // adding to the sum of squared mass matrices.
        add_matrices(temp_mm_sqrd_pt,w_pts(0,l_i));
        delete temp_mm_sqrd_pt;
      }

      // Now multiply by the Scaling sigma:
      double* current_w_values = w_pts(0,l_i)->value();
      long unsigned current_w_nnz = w_pts(0,l_i)->nnz();
      for (unsigned nnz_i = 0; nnz_i < current_w_nnz; nnz_i++)
      {
        current_w_values[nnz_i] /= Scaling_sigma;
      }

      // w_i is complete.
      // We have to create inv_w_pt by extracting the diagonal entries of w_i.

      // Get the number of local rows for this lagrange block.
      // We shall use the block in the first column.
      unsigned long l_i_nrow_local = mm_pts[0]->nrow_local();

      // A Vector for the diagonal entries of w_i.
      Vector<double> inv_w_i_diag_values(l_i_nrow_local,0.0);
      get_diag(w_pts(0,l_i),inv_w_i_diag_values);


      Vector<int> inv_w_i_row_start(l_i_nrow_local+1);
      Vector<int> inv_w_i_column_indices(l_i_nrow_local);
      // Invert the values to create the diagonal entries for inv_w_i: 
      for(unsigned long row_i = 0; row_i < l_i_nrow_local; row_i++)
      {
        inv_w_i_diag_values[row_i] = 1/inv_w_i_diag_values[row_i];
        inv_w_i_column_indices[row_i] = row_i;
        inv_w_i_row_start[row_i] = row_i;
      }

      inv_w_i_row_start[l_i_nrow_local] = l_i_nrow_local;

      inv_w_pt->build(l_i_nrow_global,
                      inv_w_i_diag_values,
                      inv_w_i_column_indices,
                      inv_w_i_row_start);
    }

//pause("DONEOOOO"); 


///////////////////////////////////////////////////////////////////////////////
   // Now we create the augmented matrix in v_aug_pt.
   // v_aug_pt is already re-ordered
   // Loop through the mm_locations
   for(unsigned ii = 0; ii < n_mm; ii++)
   {
     unsigned aug_i = mm_locations[ii];

     // We assume that the mass matrices are symmetric.
     for(unsigned jj = 0; jj < n_mm; jj++)
     {
       unsigned aug_j = mm_locations[jj];

        // A temp pointer to store the intermediate results.
        CRDoubleMatrix* aug_pt = 0;

        // being lazy, need to fix this... I am extracting the block
        // unnecessarily. This is because the multiply method requires
        // a matrix, not just a pointer.
//        this->get_block(Doftype_list_vpl[aug_i],
//                        Doftype_list_vpl[aug_j],
//                        cr_matrix_pt,aug_pt);
        this->get_block(aug_i,aug_j,cr_matrix_pt,aug_pt);

        mm_pts[ii]->multiply((*inv_w_pt),(*aug_pt));
        aug_pt->multiply(*mm_pts[jj],(*aug_pt));

        add_matrices(aug_pt,v_aug_pt(aug_i,aug_j));

        delete aug_pt;

     } // loop jj
   } // loop ii

   delete inv_w_pt;
   for(unsigned m_i = 0; m_i < n_mm; m_i++)
   {
     delete mm_pts[m_i];
   }
  } // loop through Lagrange multipliers.

//  pause("This pause 2");

  // AT this point, we have created the aumented fluid block in v_aug_pt
  // and the w block in w_pts.
  //
//*
  // Setup the fluid subsidiary precoditioner
  //
  // We solve the fluid block using different preconditioners.
  //
  // 1) For exact block preconditioning, we use the SuperLU solver.
  // For this, we have to for the fluid block.
  //
  // 2) For Exact lsc block preconditioning we do not need to form the whole
  // fluid block since the pressure and velocity are solved separately.
  //
  if(Using_superlu_ns_preconditioner)
  {

    DenseMatrix<CRDoubleMatrix* > f_aug_ptrs(N_fluid_doftypes,
                                             N_fluid_doftypes,0);
    // put in v_aug_pt:
    for(unsigned v_i = 0; v_i < N_velocity_doftypes; v_i++)
    {
      for(unsigned v_j = 0; v_j < N_velocity_doftypes; v_j++)
      {
        f_aug_ptrs(v_i,v_j) = v_aug_pt(v_i,v_j);
        //stringstream v_block_name;
        //v_block_name << "f_1aug_" << v_i << v_j;
        //f_aug_ptrs(v_i,v_j)->sparse_indexed_output(v_block_name.str());
      }
    }

    // Fill in the pressure block B
    for(unsigned col_i = 0; col_i < N_fluid_doftypes; col_i++)
    {
//      this->get_block(Doftype_list_vpl[N_velocity_doftypes],
//                      Doftype_list_vpl[col_i],
//                      cr_matrix_pt,
//                      f_aug_ptrs(N_velocity_doftypes,col_i));

      this->get_block(N_velocity_doftypes,col_i,cr_matrix_pt,
                      f_aug_ptrs(N_velocity_doftypes,col_i));
   }

    // Fill in the pressure block B^T
    for(unsigned row_i = 0; row_i < N_fluid_doftypes; row_i++)
    {
//      this->get_block(Doftype_list_vpl[row_i],
//                      Doftype_list_vpl[N_velocity_doftypes],
//                      cr_matrix_pt,
//                      f_aug_ptrs(row_i,N_velocity_doftypes));

      this->get_block(row_i,N_velocity_doftypes,cr_matrix_pt,
                      f_aug_ptrs(row_i,N_velocity_doftypes));
   }
   // output:
   /*
    for(unsigned v_i = 0; v_i < N_fluid_doftypes; v_i++)
    {
      for(unsigned v_j = 0; v_j < N_fluid_doftypes; v_j++)
      {
        stringstream v_block_name;
        v_block_name << "f_1aug_" << v_i << v_j;
        f_aug_ptrs(v_i,v_j)->sparse_indexed_output(v_block_name.str());
      }
    }
    // */

    CRDoubleMatrix* f_aug_pt = 0;

    cat(f_aug_ptrs,f_aug_pt);

    // delete the sub F pointers
    for(unsigned row_i = 0; row_i < N_fluid_doftypes; row_i++)
    {
      for(unsigned col_i = 0; col_i < N_fluid_doftypes; col_i++)
      {
        delete f_aug_ptrs(row_i, col_i);
        f_aug_ptrs(row_i, col_i) = 0;
      }
    }

    // f_aug_pt->sparse_indexed_output("f_aug1");
    if(Navier_stokes_preconditioner_pt == 0)
    {
      Navier_stokes_preconditioner_pt = new SuperLUPreconditioner;
    }
    Navier_stokes_preconditioner_pt->setup(problem_pt,f_aug_pt);
    delete f_aug_pt;
    f_aug_pt = 0;
  }
  else
  {
    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////

    DenseMatrix<CRDoubleMatrix* > f_aug_ptrs(N_fluid_doftypes,
        N_fluid_doftypes,0);
    // put in v_aug_pt:
    for(unsigned v_i = 0; v_i < N_velocity_doftypes; v_i++)
    {
      for(unsigned v_j = 0; v_j < N_velocity_doftypes; v_j++)
      {
        f_aug_ptrs(v_i,v_j) = v_aug_pt(v_i,v_j);
        //stringstream v_block_name;
        //v_block_name << "f_1aug_" << v_i << v_j;
        //f_aug_ptrs(v_i,v_j)->sparse_indexed_output(v_block_name.str());
      }
    }

    // Fill in the pressure block B
    for(unsigned col_i = 0; col_i < N_fluid_doftypes; col_i++)
    {
      //      this->get_block(Doftype_list_vpl[N_velocity_doftypes],
      //                      Doftype_list_vpl[col_i],
      //                      cr_matrix_pt,
      //                      f_aug_ptrs(N_velocity_doftypes,col_i));

      this->get_block(N_velocity_doftypes,col_i,cr_matrix_pt,
          f_aug_ptrs(N_velocity_doftypes,col_i));
    }

    // Fill in the pressure block B^T
    for(unsigned row_i = 0; row_i < N_fluid_doftypes; row_i++)
    {
      //      this->get_block(Doftype_list_vpl[row_i],
      //                      Doftype_list_vpl[N_velocity_doftypes],
      //                      cr_matrix_pt,
      //                      f_aug_ptrs(row_i,N_velocity_doftypes));

      this->get_block(row_i,N_velocity_doftypes,cr_matrix_pt,
          f_aug_ptrs(row_i,N_velocity_doftypes));
    }

//
//    // Must be in the order: F, B, Bt
//    Vector<CRDoubleMatrix*> prec_blocks(3,0);
//
//    // F block:
//    //CRDoubleMatrix* f_pt = 0;
//    cat(v_aug_pt,prec_blocks[0]);
//    // delete v_aug_pt
//    for (unsigned row_i = 0; row_i < N_velocity_doftypes; row_i++)
//    {
//      for (unsigned col_i = 0; col_i < N_velocity_doftypes; col_i++)
//      {
//        delete v_aug_pt(row_i,col_i);
//        v_aug_pt(row_i,col_i) = 0;
//      }
//    }
//
//    // Extract the b block: ///////////////////////////////////////////////////
//    double t_get_B_start = TimingHelpers::timer();
//
//    DenseMatrix<CRDoubleMatrix* > b_pts(1,N_velocity_doftypes,0);
//
//    // Encapsulation of the variable row_i
//    {
//      // The pressure block is located here in the vpl ordering.
//      unsigned row_i = N_velocity_doftypes;
//
//      // Loop through the velocity blocks columns.
//      for(unsigned col_i = 0; col_i < N_velocity_doftypes; col_i++)
//      {
//        //        this->get_block(Doftype_list_vpl[row_i], Doftype_list_vpl[col_i],
//        //                        cr_matrix_pt,b_pts(0,col_i));
//        this->get_block(row_i,col_i,cr_matrix_pt,b_pts(0,col_i));
//      }//for(unsigned col_i = 0; col_i < N_velocity_doftypes; col_i++)
//    }
//
//    double t_get_B_finish = TimingHelpers::timer();
//
//    if(Doc_time)
//    {
//      double t_get_B_time = t_get_B_finish - t_get_B_start;
//      cout << "t_get_B_time: " << t_get_B_time << "\n";
//    }
//
//    // merge the sub-blocks.
//    double t_merge_B_start = TimingHelpers::timer();
//    cat(b_pts,prec_blocks[1]);
//    double t_merge_B_finish = TimingHelpers::timer();
//    if(Doc_time)
//    {
//      double t_merge_B_time = t_merge_B_finish - t_merge_B_start;
//      cout << "t_merge_B_time: " << t_merge_B_time << "\n";
//    }
//
//    // delete the sub-blocks
//    for(unsigned col_i = 0; col_i < N_velocity_doftypes; col_i++)
//    {
//      delete b_pts(0,col_i);
//      b_pts(0,col_i) = 0;
//    }
//
//    // Extract the bt block: //////////////////////////////////////////////////
//    // (the discrete divergence block)
//    DenseMatrix<CRDoubleMatrix* > bt_pts(N_velocity_doftypes,1,0);
//
//    double t_get_Bt_start = TimingHelpers::timer();
//    {
//      unsigned col_i = N_velocity_doftypes;
//      for(unsigned row_i = 0; row_i < N_velocity_doftypes; row_i++)
//      {
//        //        this->get_block(Doftype_list_vpl[row_i], Doftype_list_vpl[col_i],
//        //                        cr_matrix_pt,bt_pts(row_i,0));
//        this->get_block(row_i,col_i,cr_matrix_pt,bt_pts(row_i,0));
//      }//for(unsigned row_i = 0; row_i < N_velocity_doftypes; row_i++)
//    }
//
//    double t_get_Bt_finish = TimingHelpers::timer();
//
//    if(Doc_time)
//    {
//      double t_get_Bt_time = t_get_Bt_finish - t_get_Bt_start;
//      cout << "t_get_Bt_time: " << t_get_Bt_time << "\n";
//    }
//
//    double t_merge_Bt_start = TimingHelpers::timer();
//    cat(bt_pts,prec_blocks[2]);
//    double t_merge_Bt_finish = TimingHelpers::timer();
//
//    prec_blocks[2]->sparse_indexed_output("Bt");
//    if(Doc_time)
//    {
//      double t_merge_Bt_time = t_merge_Bt_finish - t_merge_Bt_start;
//      cout << "t_merge_Bt_time: " << t_merge_Bt_time << "\n";
//    }
//
//    // Delete sub-blocks
//    for(unsigned row_i = 0; row_i < N_velocity_doftypes; row_i++)
//    {
//      delete bt_pts(row_i,0);
//      bt_pts(row_i,0) = 0;
//    }
//
//
//    // output:
//    /*
//       for(unsigned v_i = 0; v_i < N_fluid_doftypes; v_i++)
//       {
//       for(unsigned v_j = 0; v_j < N_fluid_doftypes; v_j++)
//       {
//       stringstream v_block_name;
//       v_block_name << "f_1aug_" << v_i << v_j;
//       f_aug_ptrs(v_i,v_j)->sparse_indexed_output(v_block_name.str());
//       }
//       }
//
//*/
//

    Vector<unsigned> ns_dof_list(N_fluid_doftypes,0);
    for (unsigned i = 0; i < N_fluid_doftypes; i++)
    {
      ns_dof_list[i]= Doftype_list_bcpl[i];
      //      std::cout << "ns_dof_list: " << ns_dof_list[i] << std::endl; 
    }

    // Determine whether the NS preconditioner is a block preconditioner (and
    // therefore a subsidiary preconditioner)
#ifdef PARANOID
    BlockPreconditioner<CRDoubleMatrix>* Navier_stokes_block_preconditioner_pt
      = dynamic_cast<BlockPreconditioner<CRDoubleMatrix>* >
      (Navier_stokes_preconditioner_pt);
    if(Navier_stokes_block_preconditioner_pt == 0)
    {
      std::ostringstream error_message;
      error_message << "Navier stokes preconditioner is not a block\n"
        << "preconditioner." << std::endl;
      throw OomphLibError(
          error_message.str(),
          "LagrangeEnforcedflowPreconditioner::setup()",
          OOMPH_EXCEPTION_LOCATION);
    }
#else
    BlockPreconditioner<CRDoubleMatrix>* Navier_stokes_block_preconditioner_pt
      = static_cast<BlockPreconditioner<CRDoubleMatrix>* >
      (Navier_stokes_preconditioner_pt);
#endif



    Navier_stokes_block_preconditioner_pt
      ->turn_into_subsidiary_block_preconditioner(this, ns_dof_list);

    //    Navier_stokes_block_preconditioner_pt
    //      ->set_master_doftype_ordering(Doftype_list_vpl);

//    Navier_stokes_block_preconditioner_pt
//      ->set_prec_blocks(prec_blocks);
    Navier_stokes_block_preconditioner_pt
      ->set_prec_blocks(f_aug_ptrs);

    Navier_stokes_block_preconditioner_pt
      ->setup(problem_pt,matrix_pt);

    //delete prec_blocks[0];
    //delete prec_blocks[1];
    //delete prec_blocks[2];

    //delete j_aug_pt;
    //j_aug_pt = 0;
    //pause("dat pause");
    // To do

  }
//  */
//delete v_aug_pt;
//CLEAR w_pts

////////////////////////////////////////////////////////////////////////////////

  // Solver for the W block.
  double t_w_prec_start = TimingHelpers::timer();
  W_preconditioner_pts.resize(N_lagrange_doftypes);
  for(unsigned l_i = 0; l_i < N_lagrange_doftypes; l_i++)
  {
    if(Using_superlu_w_preconditioner)
    {
      if(W_preconditioner_pts[l_i] == 0)
      {
        W_preconditioner_pts[l_i] = new SuperLUPreconditioner;
      }

      W_preconditioner_pts[l_i]->setup(problem_pt,w_pts(0,l_i));
    }
    else
    {
      pause("Other W preconditioners are not yet implemented.");
    }
  }
  double t_w_prec_finish = TimingHelpers::timer();
  if(Doc_time)
  {
    double t_w_prec_time = t_w_prec_finish - t_w_prec_start;
    cout << "t_w_prec_time: "
      << t_w_prec_time << "\n";
  }

  // Delete w_pts(0,N_lagrange_doftypes)
  for (unsigned l_i = 0; l_i < N_lagrange_doftypes; l_i++) 
  {
    delete w_pts(0,l_i);
  }

  Mapping_info_calculated = true;
 } // end of LagrangeEnforcedflowPreconditioner::setup


 //========================================================================
 /// \short Clears the memory.
 //========================================================================
 void LagrangeEnforcedflowPreconditioner::clean_up_memory()
 {
  // clean the block preconditioner base class memory
  this->clear_block_preconditioner_base();
 } // end of LagrangeEnforcedflowPreconditioner::clean_up_memory


/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////



//========================================================================
/// Helper function to assemble the diagonal of the velocity
/// mass matrix from the elemental contributions defined in
/// NavierStokesEquations<DIM>::get_velocity_mass_matrix_diagonal(...).
/// If do_both=true, both are computed, otherwise only the velocity
/// mass matrix (the LSC version of the preconditioner only needs
/// that one)
//========================================================================
 void LagrangeEnforcedflowPreconditioner::
  assemble_inv_press_and_veloc_mass_matrix_diagonal(
  CRDoubleMatrix*& inv_p_mass_pt,
  CRDoubleMatrix*& inv_v_mass_pt,
  const bool& do_both,
  const unsigned& procnumber,Problem* problem_pt)
 {
  int pronumber = (int)procnumber;
  // determine the velocity rows required by this processor
  // RRR_type
  unsigned v_first_row = this->block_distribution_pt(pronumber)->first_row();
  unsigned v_nrow_local = this->block_distribution_pt(pronumber)->nrow_local();
  unsigned v_nrow = this->block_distribution_pt(pronumber)->nrow();

 //cout << "v_first_row = " << v_first_row << endl;
 //cout << "v_nrow_local = " << v_nrow_local << endl;
 //cout << "v_nrow = " << v_nrow << endl;

  // create storage for the diagonals
  double* v_values = new double[v_nrow_local];
  for (unsigned i = 0; i < v_nrow_local; i++)
   {
    v_values[i] = 0.0;
   }

  // Equivalent information for pressure mass matrix (only needed for
  // Fp version)
  //unsigned p_first_row=0;
  //unsigned p_nrow_local=0;
  //unsigned p_nrow=0;
  //double* p_values = 0;
/*
  if (L_prec_type != Exact_lsc_block_preconditioner)
   {
    // determine the pressure rows required by this processor
    p_first_row = this->block_distribution_pt(1)->first_row();
    p_nrow_local = this->block_distribution_pt(1)->nrow_local();
    p_nrow = this->block_distribution_pt(1)->nrow();

    // create storage for the diagonals
    p_values = new double[p_nrow_local];
    for (unsigned i = 0; i < p_nrow_local; i++)
     {
      p_values[i] = 0.0;
     }
   } // if (!Use_LSC)
   */

  // store the problem pt, this seems to be not used.
  //const Problem* problem_pt = this->problem_pt();

  // if the problem is distributed
  bool distributed = false;

  if (distributed)
   {
   // To do
   }
  else
   {
    // find number of elements
    unsigned n_el = Meshes_pts[0]->nelement();

    //unsigned n_el = problem_pt->mesh_pt(0)->nelement();
    // Fp needs pressure and velocity mass matrices
    unsigned which_one=0;
    if (1)
      which_one=2;

    // get the contribution for each element
    for (unsigned e = 0; e < n_el; e++)
     {
      // Get element
      //GeneralisedElement* el_pt=problem_pt->mesh_pt(0)->element_pt(e);
      GeneralisedElement* el_pt=Meshes_pts[0]->element_pt(e);

      // find number of degrees of freedom in the element
      // (this is slightly too big because it includes the
      // pressure dofs but this doesn't matter)
      unsigned el_dof = el_pt->ndof();

      // allocate local storage for the element's contribution to the
      // pressure and velocity mass matrix diagonal
      Vector<double> el_vmm_diagonal(el_dof);
      Vector<double> el_pmm_diagonal(el_dof);

      dynamic_cast<TemplateFreeNavierStokesEquationsBase*>(el_pt)->
       get_pressure_and_velocity_mass_matrix_diagonal(
        el_pmm_diagonal,el_vmm_diagonal,which_one);

      // Get the contribution for each dof
      for (unsigned i = 0; i < el_dof; i++)
       {
        //Get the equation number
        unsigned eqn_number = el_pt->eqn_number(i);

        // Get the velocity dofs
        if (this->block_number(eqn_number)==pronumber) // RAY_TOCHANGE
         {
         //cout << "GOT HERE!!!!" << endl;
          // get the index in the block
          unsigned index = this->index_in_block(eqn_number);

          // if it is required on this processor
          if ((index >= v_first_row) &&
              (index < (v_first_row + v_nrow_local) ) )
           {
           //cout << "ZOMG Got in if" << endl;
           //cout << "index-v_first_row = " << index-v_first_row << endl;
            v_values[index-v_first_row] += el_vmm_diagonal[i];
           }
         }
        // Get the pressure dofs
        // NOTE: This is not used for the LSC case.
        else if (this->block_number(eqn_number)==1) // RAY_TOCHANGE
         {
          /*
           if (L_prec_type != Exact_lsc_block_preconditioner)
           {
            // get the index in the block
            unsigned index = this->index_in_block(eqn_number);

            // if it is required on this processor
            if ((index >= p_first_row)&&
                (index < (p_first_row + p_nrow_local)) )
             {
              p_values[index-p_first_row] += el_pmm_diagonal[i];
             }
           } // if (!Use_LSC)
           */
         }
       }
     } // for (unsigned e = 0; e < n_el; e++)
   }// if (distributed), else

  // Create column index and row start for velocity mass matrix
  int* v_column_index = new int[v_nrow_local];
  int* v_row_start = new int[v_nrow_local+1];
  for (unsigned i = 0; i < v_nrow_local; i++)
   {
#ifdef PARANOID
    if (v_values[i]==0.0)
     {
      std::ostringstream error_message;
      error_message << "Zero entry in diagonal of velocity mass matrix\n"
                    << "Index: " << i << std::endl;
      throw OomphLibError(
       error_message.str(),
       "ConstrainedNavierStokesSchurComplementPreconditioner::assemble_inv_press_and_veloc_mass_matrix_diagonal()",
       OOMPH_EXCEPTION_LOCATION);
     }
#endif
    v_values[i] = 1.0/v_values[i];
    v_column_index[i] = v_first_row + i;
    v_row_start[i] = i;
   }
  v_row_start[v_nrow_local] = v_nrow_local;

  // Build the velocity mass matrix
  inv_v_mass_pt = new CRDoubleMatrix(this->block_distribution_pt(pronumber));
  inv_v_mass_pt->build_without_copy(v_nrow,v_nrow_local,
                                    v_values,v_column_index,
                                    v_row_start);
  /*
  // Create pressure mass matrix
  if (L_prec_type != Exact_lsc_block_preconditioner)
   {
    // Create column index and row start for pressure mass matrix
    int* p_column_index = new int[p_nrow_local];
    int* p_row_start = new int[p_nrow_local+1];
    for (unsigned i = 0; i < p_nrow_local; i++)
     {

#ifdef PARANOID
      if (p_values[i]==0.0)
       {
        std::ostringstream error_message;
        error_message << "Zero entry in diagonal of pressure mass matrix\n"
                      << "Index: " << i << std::endl;
        throw OomphLibError(
         error_message.str(),
         "ConstrainedNavierStokesSchurComplementPreconditioner::assemble_inv_press_and_veloc_mass_matrix_diagonal()",
         OOMPH_EXCEPTION_LOCATION);
       }
#endif
      p_values[i] = 1.0/p_values[i];

      p_column_index[i] = p_first_row + i;
      p_row_start[i] = i;
     }
    p_row_start[p_nrow_local] = p_nrow_local;

    // Build the pressure mass matrix
    inv_p_mass_pt = new CRDoubleMatrix(this->block_distribution_pt(1)); // This also needs to change.
    inv_p_mass_pt->build_without_copy(p_nrow,p_nrow_local,
                                      p_values,p_column_index,
                                      p_row_start);

   } // if (!Use_LSC)
  */
 }
// void LagrangeEnforcedflowPreconditioner::assemble_inv_press_and_veloc_mass_matrix_diagonal



}
#endif
