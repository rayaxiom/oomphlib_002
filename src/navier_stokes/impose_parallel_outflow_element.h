//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//           Version 0.90. August 3, 2009.
//LIC// 
//LIC// Copyright (C) 2006-2009 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
#ifndef OOMPH_IMPOSE_PARALL_ELEMENTS_HEADER
#define OOMPH_IMPOSE_PARALL_ELEMENTS_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

namespace oomph
{
//========================================================================
/// \short  ImposeParallelOutflowElement 
/// are elements that coincide with the faces of
/// higher-dimensional "bulk" elements. They are used on 
/// boundaries where we would like to impose parallel outflow and 
/// impose the pressure.
//========================================================================
 template <class ELEMENT>
  class ImposeParallelOutflowElement :
  public virtual FaceGeometry<ELEMENT>,
  public virtual FaceElement
  {
   private :  

   /// pointer to imposed pressure -- if null then no pressure imposed.
   double* Pressure_pt;
   
   /// Lagrange Id
   unsigned Id;

    public:   

   /// \short Constructor takes a "bulk" element, the
   /// index that identifies which face the 
   /// ImposeParallelOutflowElement is supposed
   /// to be attached to, and the face element ID
   ImposeParallelOutflowElement
    (FiniteElement* const &element_pt, 
     const int &face_index,const unsigned &id=0) :
    FaceGeometry<ELEMENT>(), FaceElement()
    {
     //  set the Id
     Id=id;
     
     //Build the face element
     element_pt->build_face_element(face_index,this);
      
     // dimension of the bulk element
     unsigned dim=element_pt->dim();

     // we need dim-1 additional values for each FaceElement node
     Vector<unsigned> n_additional_values(nnode(), dim-1);

     // add storage for lagrange multipliers and set the map containing 
     // the position of the first entry of this face element's 
     // additional values.
     add_additional_values(n_additional_values,id);

     // set the pressure pointer to zero
     Pressure_pt=0;
    }

   /// Fill in the residuals
   void fill_in_contribution_to_residuals(Vector<double> &residuals)
    {
     //Call the generic routine with the flag set to 0
     fill_in_generic_contribution_to_residuals_parall_lagr_multiplier(
      residuals,GeneralisedElement::Dummy_matrix,0);
    }

   /// Fill in contribution from Jacobian
   void fill_in_contribution_to_jacobian(Vector<double> &residuals,
                                         DenseMatrix<double> &jacobian)
    {
     //Call the generic routine with the flag set to 1
     fill_in_generic_contribution_to_residuals_parall_lagr_multiplier(
      residuals,jacobian,1);
    }

   ///Overload the output function
   void output(std::ostream &outfile) {FiniteElement::output(outfile);}

   ///Output function: x,y,[z],u,v,[w],p in tecplot format
   void output(std::ostream &outfile, const unsigned &nplot)
    {FiniteElement::output(outfile,nplot);}
   
   /// \short The "global" intrinsic coordinate of the element when
   /// viewed as part of a geometric object should be given by
   /// the FaceElement representation, by default
   /// This final over-ride is required because both SolidFiniteElements 
   /// and FaceElements overload zeta_nodal
   double zeta_nodal(const unsigned &n, const unsigned &k,           
                     const unsigned &i) const 
   {return FaceElement::zeta_nodal(n,k,i);}     
   

   ///  Access function for the pressure
   double* &pressure_pt() {return Pressure_pt;}
   
    protected:
   
   /// \short Helper function to compute the residuals and, if flag==1, the
   /// Jacobian
   void fill_in_generic_contribution_to_residuals_parall_lagr_multiplier(
    Vector<double> &residuals,
    DenseMatrix<double> &jacobian,
    const unsigned& flag)
    {
     //Find out how many nodes there are
     unsigned n_node = nnode();

     // Dimension of element
     unsigned dim_el=dim();

     //Set up memory for the shape functions
     Shape psi(n_node);

     //Set the value of n_intpt
     unsigned n_intpt = integral_pt()->nweight();

     //to store local equation number
     int local_eqn=0;
     int local_unknown=0;

     //to store normal vector
     Vector<double> norm_vec(dim_el+1);

     //to store tangantial vectors
     Vector<Vector<double> > tang_vec(dim_el,Vector<double>(dim_el+1));

     //get the value at which the velocities are stored
     Vector<unsigned> u_index(dim_el+1);
     ELEMENT *el_pt = dynamic_cast<ELEMENT*>(this->bulk_element_pt());
     for(unsigned i=0;i<dim_el+1;i++) {u_index[i] = el_pt->u_index_nst(i);}
     
     //Loop over the integration points
     for(unsigned ipt=0;ipt<n_intpt;ipt++)
      {
       //Get the integral weight
       double w = integral_pt()->weight(ipt);

       //Jacobian of mapping
       double J=J_eulerian_at_knot(ipt);

       //Premultiply the weights and the Jacobian
       double W = w*J;

       //Calculate the shape functions
       shape_at_knot(ipt,psi);

       //compute  the velocity and the Lagrange multiplier
       Vector<double> interpolated_u(dim_el+1,0.0);
       Vector<double> lambda(dim_el,0.0);
       // Loop over nodes
       for(unsigned j=0;j<n_node;j++)
        {
         //Assemble the velocity component
         for(unsigned i=0;i<dim_el+1;i++)
          {
           interpolated_u[i] += nodal_value(j,u_index[i])*psi(j);
          }
         
         // Cast to a boundary node
         BoundaryNodeBase *bnod_pt = 
          dynamic_cast<BoundaryNodeBase*>(node_pt(j));
     
         // get the node
         Node* nod_pt = node_pt(j);

         // Get the index of the first nodal value associated with
         // this FaceElement
         unsigned first_index=
          bnod_pt->index_of_first_value_assigned_by_face_element(Id);
        
         //Assemble the Lagrange multiplier
         for(unsigned l=0;l<dim_el;l++)
          {
           lambda[l]+=nod_pt->value(first_index+l) * psi(j);
          }
        }

       // compute the normal vector
       tangent_and_outer_unit_normal(ipt,tang_vec,norm_vec);
       
        /* 
       streamsize outfile_precision = cout.precision();

        cout << "oh hai, normal is: " << setprecision(15) << endl;
        cout << "RAYNOMAL: " << norm_vec[0] << " " 
                             << norm_vec[1] << endl;
        cout << "oh hai, tangent is: " << endl;
        cout << "RAYTANGENT 0: " << tang_vec[0][0] << " "
                               << tang_vec[0][1] << " "
                               << setprecision(outfile_precision) << endl;
        // */
     //cout << "Also, e = " << std::numeric_limits<double>::epsilon() << endl;

       // compute the tangantial vectors
       //get_tang_vec(dim_el,norm_vec,tang_vec);


       
       // RAYRAY
      // cout << "testing tangent" << endl;
       //tangent(ipt,tang_vec);

      // cout << "testing tangent and unit normal" << endl;
      // tangent_and_outer_unit_normal(ipt,tang_vec,norm_vec);


//pause("Done yo!");

       // Assemble residuals and jacobian

       //Loop over the nodes
       for(unsigned j=0;j<n_node;j++)
        {
         // Cast to a boundary node
         BoundaryNodeBase *bnod_pt = 
          dynamic_cast<BoundaryNodeBase*>(node_pt(j));

         // Get the index of the first nodal value associated with
         // this FaceElement
         unsigned first_index=
          bnod_pt->index_of_first_value_assigned_by_face_element(Id);
        
         //loop over the lagrange multiplier components
         for(unsigned l=0;l<dim_el;l++) 
          { 
           // Local eqn number for the l-th component of lamdba 
           //in the j-th element
           local_eqn=nodal_local_eqn(j,first_index+l); 

           if (local_eqn>=0) 
            {   
             for(unsigned i=0; i<dim_el+1; i++) 
              { 
               // Assemble residual for lagrange multiplier
               residuals[local_eqn]+= 
                interpolated_u[i] * tang_vec[l][i] * psi(j)* W;

               // Assemble Jacobian for Lagrange multiplier:
               if (flag==1)
                {
                 // Loop over the nodes again for unknowns
                 for(unsigned jj=0;jj<n_node;jj++)
                  {
                   // Local eqn number for the i-th component 
                   //of the velocity in the jj-th element 
                   local_unknown=nodal_local_eqn(jj,u_index[i]);
                   if (local_unknown>=0)
                    {
                     jacobian(local_eqn,local_unknown)+=
                      tang_vec[l][i]*psi(jj)*psi(j)*W;
                    }
                  }
                }
              }
            }
          }

         //Loop over the directions
         for(unsigned i=0;i<dim_el+1;i++)
          {
           // Local eqn number for the i-th component of the
           //velocity in the j-th element 
           local_eqn = nodal_local_eqn(j,u_index[i]);
           
           if (local_eqn>=0)
            {
             // Add the contribution of the imposed pressure
             if (Pressure_pt!=0)
              {
               residuals[local_eqn]-= (*Pressure_pt)* norm_vec[i]*psi(j)*W; 
              }

             // Add lagrange multiplier contribution to the bulk equation
             for(unsigned l=0;l<dim_el;l++) 
              {
               // Add to residual
               residuals[local_eqn]+=tang_vec[l][i]*psi(j)*lambda[l]*W; 

               // Do Jacobian too?
               if (flag==1)
                {
                 // Loop over the nodes again for unknowns
                 for(unsigned jj=0;jj<n_node;jj++)
                  {
                   // Cast to a boundary node
                   BoundaryNodeBase *bnode_pt = 
                    dynamic_cast<BoundaryNodeBase*>(node_pt(jj));

                   // Local eqn number for the l-th component of lamdba
                   // in the jj-th element
                   local_unknown=nodal_local_eqn
                    (jj,bnode_pt->
                     index_of_first_value_assigned_by_face_element(Id)+l);
                   if (local_unknown>=0)
                    {
                     jacobian(local_eqn,local_unknown)+=
                      tang_vec[l][i]*psi(jj)*psi(j)*W;
                    } // if
                  } // for
                } // if
              } // for
            } // if
          } // for loop over directions
        } // for loop over nodes
      } // for loop over int points
    // pause("Done all integration points for this element!");
    } // end of function?
   
  /* 
   bool doubles_are_same(double a, double b)
   {
         return fabs(a - b) < 1e-14;
   }
   
   /// function to compute the tangantial vectors from the normal vector
   void get_tang_vec(const unsigned &dim_el, const Vector<double> &N,
                     Vector<Vector<double> > &T)
    {
     T.resize(dim_el,Vector<double>(dim_el+1));
     double a,b,c;
     switch(dim_el)
      {
      case 1:
       T[0][0]=-N[1];
       T[0][1]=N[0];
       break;
      case 2:
       a=N[0];
       b=N[1];
       c=N[2]; 
     
       
       if(!doubles_are_same(0.0,a) || !doubles_are_same(0.0,b))
       {
         double a_sq=a*a;
         double b_sq=b*b;
         double c_sq=c*c;
         
         T[0][0]=-b /sqrt(a_sq+b_sq);
         T[0][1]= a /sqrt(a_sq+b_sq);
         T[0][2]=0;
	  
         double z=(a_sq +b_sq)
          /sqrt(a_sq*c_sq +b_sq*c_sq +(a_sq +b_sq)*(a_sq +b_sq)) ;
	  
         T[1][0]=-(a*c*z)/(a_sq + b_sq) ;
         T[1][1]= -(b*c*z)/(a_sq + b_sq);
         T[1][2]= z;
         // NB : we didn't use the fact that N is normalized,
         // that's why we have these insimplified formulas
        }
       else if (!doubles_are_same(0.0,c))
	     {
         T[0][0]=1.0;
         T[0][1]= 0.0;	  
         T[0][2]= 0.0;
	  
         T[1][0]=0.0;
         T[1][1]= 1.0;	  
         T[1][2]= 0.0;
       }
       else
	{
         throw 
          OomphLibError("You have a zero normal vector!! ",
                        "ImposeParallelOutflowElement::get_tang_vec",
                        OOMPH_EXCEPTION_LOCATION);
	}
       break;

      default:
       throw 
        OomphLibError(
         " unexcpected lagrange elements's dimension ",
         "ImposeParallelOutflowElement::get_tang_vec",
         OOMPH_EXCEPTION_LOCATION);
      }
    }

// */

 /// \short The number of "blocks" that degrees of freedom in this element
 /// are sub-divided into: Just the solid degrees of freedom themselves.
 unsigned ndof_types()
 {
  // This is the elemental dimension. So in a 
  // 2D problem this is 1, which corresponds
  // to the single Lagrange multipler introduced
  // by this element.
  return (this->dim() + additional_ndof_types());
 }

 unsigned additional_ndof_types()
 {
   // Additional dof types for the constained bulk velocities
   // two velocities for a 2D problem, 3 for 3D.
   return (this->dim() + 1);
 }
 
 /// \short Create a list of pairs for all unknowns in this element,
 /// so that the first entry in each pair contains the global equation
 /// number of the unknown, while the second one contains the number
 /// of the "block" that this unknown is associated with.
 /// (Function can obviously only be called if the equation numbering
 /// scheme has been set up.) 
 void get_dof_numbers_for_unknowns(
  std::list<std::pair<unsigned long,unsigned> >& block_lookup_list)
 {
  
  // temporary pair (used to store block lookup prior to being added to list)
  std::pair<unsigned,unsigned> block_lookup;
  
  // number of nodes
  const unsigned n_node = this->nnode();
  //Loop over directions in this Face(!)Element
  unsigned dim_el = this->dim();
  for(unsigned i=0;i<dim_el;i++)
  {     
    //Loop over the nodes
    for(unsigned j=0;j<n_node;j++)
    {          
      // Cast to a boundary node
      BoundaryNodeBase *bnod_pt = 
       dynamic_cast<BoundaryNodeBase*>(node_pt(j));
      
      // Local eqn number:
      int local_eqn=nodal_local_eqn
       (j,bnod_pt->index_of_first_value_assigned_by_face_element(Id)+i);
      if (local_eqn>=0)
      {
        // store block lookup in temporary pair: First entry in pair
        // is global equation number; second entry is block type
        // We assume that the first 2(3) types are fluid dof types in
        // 2(3) spatial dimensions:
        //
        // 0  1  2  3  8 
        // up vp wp L1 L2]
        // So we add the additional_ndof_types() which in this case
        // corresponds to the number of spatial dimensions of the problem.
        block_lookup.first = this->eqn_number(local_eqn);
        block_lookup.second = i +additional_ndof_types();
        
        //cout << "Face L: " << block_lookup.first << " doftype: " << block_lookup.second << std::endl;
        // add to list
        block_lookup_list.push_front(block_lookup);
      } // if local_eqn > 0
    } // for loop over nodes
  } // for loop over directions
 //pause("done one face element!");

  //*
  // Now we do the bulk elements. Each velocity component of a constrained dof
  // of a different type of FaceElement has a different dof_type. E.g. Consider
  // the Navier Stokes equations in three spatial dimensions with parallel
  // outflow (using ImposeParallelOutflowElement with Boundary_id = 1) and
  // tangential flow (using ImposeTangentialFlowElement with Boundary_id = 2)
  // imposed along two different boundaries. 
  // There will be 10 dof types: 
  // 0 1 2 3 4  5  6  7  8  9 
  // u v w p u1 v1 w1 u2 v2 w2

  // Loop over only the nodes of the "bulk" element that are associated 
  // with this "face" element.
  //cout << "n_node: " << n_node << endl;
  unsigned const bulk_dim = dim_el + 1;
  //cout << "bulk_dim: " << bulk_dim << endl;
  for(unsigned node_i = 0; node_i < n_node; node_i++)
  {
    // Loop over the velocity components
    for(unsigned velocity_i = 0; velocity_i < bulk_dim; velocity_i++)
    {
      // Calculating the offset for this Boundary_id.
      // 0 1 2 3 4  5  6  7  8  9
      // u v w p u1 v1 w1 u2 v2 w2
      // 
      // for the first surface mesh, offset = 4
      // for the second surface mesh, offset = 7
      //unsigned offset = bulk_dim * Boundary_id + 1;
      
      // The local equation number is required to check if the value is pinned,
      // if it is not pinned, the local equation number is required to get the
      // global equation number.
      int local_eqn = Bulk_element_pt
                      ->nodal_local_eqn(Bulk_node_number[node_i],
                                        velocity_i);

      // ignore pinned values
      if(local_eqn >= 0)
      {
        // store the block loopup in temporary pair: First entry in pair
        // is the global equation number; second entry is the block type
        block_lookup.first = Bulk_element_pt->eqn_number(local_eqn);
        block_lookup.second = velocity_i;
        block_lookup_list.push_front(block_lookup);

        //RRRcout << "Face v: " <<  block_lookup.first
        //RRR     << ", doftype: " << block_lookup.second << endl;

      } // ignore pinned nodes "if(local-eqn>=0)"
    } // for loop over the velocity components
  } //  for loop over bulk nodes only
  //pause("Done one face elemento!");
  // */
 } // get_dof_numbers_for_unknowns
 
 // hierher kill this
 void fill_in_contribution_to_jacobian_and_mass_matrix(
  Vector<double> &residuals,
  DenseMatrix<double> &jacobian, DenseMatrix<double> &mass_matrix)
 {
  std::cout << "hierher kill this \n";
 }
 
  };

}

#endif
